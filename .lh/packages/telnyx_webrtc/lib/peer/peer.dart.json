{
    "sourceFile": "packages/telnyx_webrtc/lib/peer/peer.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1730809569544,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1730809600452,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -273,9 +273,9 @@\n             userAgent: \"Flutter-1.0\");\n         var answerMessage = InviteAnswerMessage(\n             id: const Uuid().v4(),\n             jsonrpc: JsonRPCConstant.jsonrpc,\n-            method: SocketMethod.ANSWER,\n+            method: isAttach ? SocketMethod.ATTACH : SocketMethod.ANSWER,\n             params: inviteParams);\n \n         String jsonAnswerMessage = jsonEncode(answerMessage);\n         _send(jsonAnswerMessage);\n"
                },
                {
                    "date": 1732094808505,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -284,8 +284,20 @@\n       _logger.e(\"Peer :: $e\");\n     }\n   }\n \n+  Future<void> getStats(RTCPeerConnection peerConnection) async {\n+    peerConnection.getStats(null).then((value) {\n+      value.forEach((report) {\n+        _logger.i(\"Stats: {\");\n+        report.values.forEach((key, value) {\n+          _logger.i(\"$key: $value\");\n+        });\n+        _logger.i(\"}\");\n+      });\n+    });\n+  }\n+\n   void closeSession() {\n     var sess = _sessions[_selfId];\n     if (sess != null) {\n       _logger.d(\"Session end success\");\n"
                },
                {
                    "date": 1732103558178,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -201,9 +201,10 @@\n       String destinationNumber,\n       String clientState,\n       String callId,\n       IncomingInviteParams invite,\n-      Map<String, String> customHeaders,bool isAttach) async {\n+      Map<String, String> customHeaders,\n+      bool isAttach) async {\n     var sessionId = _selfId;\n     Session session = await _createSession(null,\n         peerId: \"0\", sessionId: sessionId, media: \"audio\");\n     _sessions[sessionId] = session;\n@@ -211,9 +212,9 @@\n     await session.peerConnection\n         ?.setRemoteDescription(RTCSessionDescription(invite.sdp, \"offer\"));\n \n     _createAnswer(session, \"audio\", callerName, callerNumber, destinationNumber,\n-        clientState, callId, customHeaders,isAttach);\n+        clientState, callId, customHeaders, isAttach);\n \n     onCallStateChange?.call(session, CallState.active);\n   }\n \n@@ -224,9 +225,10 @@\n       String callerNumber,\n       String destinationNumber,\n       String clientState,\n       String callId,\n-      Map<String, String> customHeaders,bool isAttach) async {\n+      Map<String, String> customHeaders,\n+      bool isAttach) async {\n     try {\n       session.peerConnection?.onIceCandidate = (candidate) async {\n         if (session.peerConnection != null) {\n           _logger.i(\"Peer :: Add Ice Candidate!\");\n"
                },
                {
                    "date": 1732103618535,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -372,8 +372,11 @@\n       switch (state) {\n         case RTCIceConnectionState.RTCIceConnectionStateFailed:\n           peerConnection.restartIce();\n           return;\n+        case RTCIceConnectionState.RTCIceConnectionStateConnected:\n+          getStats(peerConnection);\n+          return;\n         default:\n           return;\n       }\n     };\n"
                }
            ],
            "date": 1730809569544,
            "name": "Commit-0",
            "content": "import 'dart:convert';\nimport 'dart:async';\nimport 'dart:math';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter_webrtc/flutter_webrtc.dart';\nimport 'package:telnyx_webrtc/config.dart';\nimport 'package:telnyx_webrtc/model/socket_method.dart';\nimport 'package:telnyx_webrtc/model/verto/send/invite_answer_message_body.dart';\nimport 'package:telnyx_webrtc/tx_socket.dart'\n    if (dart.library.js) 'package:telnyx_webrtc/tx_socket_web.dart';\nimport 'package:uuid/uuid.dart';\nimport 'package:logger/logger.dart';\nimport 'package:telnyx_webrtc/model/verto/receive/received_message_body.dart';\nimport '../model/call_state.dart';\nimport '../model/jsonrpc.dart';\n\nenum SignalingState {\n  ConnectionOpen,\n  ConnectionClosed,\n  ConnectionError,\n}\n\nclass Session {\n  Session({required this.sid, required this.pid});\n\n  String pid;\n  String sid;\n  RTCPeerConnection? peerConnection;\n  RTCDataChannel? dc;\n  List<RTCIceCandidate> remoteCandidates = [];\n}\n\nclass Peer {\n  Peer(this._socket);\n\n  final _logger = Logger();\n\n  final String _selfId = randomNumeric(6);\n\n  final TxSocket _socket;\n\n  final Map<String, Session> _sessions = {};\n  MediaStream? _localStream;\n  final List<MediaStream> _remoteStreams = <MediaStream>[];\n\n  Function(SignalingState state)? onSignalingStateChange;\n  Function(Session session, CallState state)? onCallStateChange;\n  Function(MediaStream stream)? onLocalStream;\n  Function(Session session, MediaStream stream)? onAddRemoteStream;\n  Function(Session session, MediaStream stream)? onRemoveRemoteStream;\n  Function(dynamic event)? onPeersUpdate;\n  Function(Session session, RTCDataChannel dc, RTCDataChannelMessage data)?\n      onDataChannelMessage;\n  Function(Session session, RTCDataChannel dc)? onDataChannel;\n\n  String get sdpSemantics =>\n      WebRTC.platformIsWindows ? 'plan-b' : 'unified-plan';\n\n  final Map<String, dynamic> _iceServers = {\n    'iceServers': [\n      {\n        'url': DefaultConfig.defaultStun,\n        'username': DefaultConfig.username,\n        'credential': DefaultConfig.password\n      },\n      {\n        'url': DefaultConfig.defaultTurn,\n        'username': DefaultConfig.username,\n        'credential': DefaultConfig.password\n      },\n    ]\n  };\n\n  final Map<String, dynamic> _dcConstraints = {\n    'mandatory': {\n      'OfferToReceiveAudio': true,\n      'OfferToReceiveVideo': false,\n    },\n    'optional': [\n      {'DtlsSrtpKeyAgreement': true},\n    ],\n  };\n\n  close() async {\n    await _cleanSessions();\n  }\n\n  void muteUnmuteMic() {\n    if (_localStream != null) {\n      bool enabled = _localStream!.getAudioTracks()[0].enabled;\n      _localStream!.getAudioTracks()[0].enabled = !enabled;\n    } else {\n      _logger.d(\"Peer :: No local stream :: Unable to Mute / Unmute\");\n    }\n  }\n\n  void enableSpeakerPhone(bool enable) {\n    if (_localStream != null) {\n      _localStream!.getAudioTracks()[0].enableSpeakerphone(enable);\n    } else {\n      _logger.d(\"Peer :: No local stream :: Unable to toggle speaker mode\");\n    }\n  }\n\n  void invite(\n      String callerName,\n      String callerNumber,\n      String destinationNumber,\n      String clientState,\n      String callId,\n      String telnyxSessionId,\n      Map<String, String> customHeaders) async {\n    var sessionId = _selfId;\n\n    Session session = await _createSession(null,\n        peerId: \"0\", sessionId: sessionId, media: \"audio\");\n\n    _sessions[sessionId] = session;\n\n    _createOffer(session, \"audio\", callerName, callerNumber, destinationNumber,\n        clientState, callId, telnyxSessionId, customHeaders);\n    onCallStateChange?.call(session, CallState.newCall);\n  }\n\n  Future<void> _createOffer(\n      Session session,\n      String media,\n      String callerName,\n      String callerNumber,\n      String destinationNumber,\n      String clientState,\n      String callId,\n      String sessionId,\n      Map<String, String> customHeaders) async {\n    try {\n      RTCSessionDescription s =\n          await session.peerConnection!.createOffer(_dcConstraints);\n      await session.peerConnection!.setLocalDescription(s);\n\n      if (session.remoteCandidates.isNotEmpty) {\n        for (var candidate in session.remoteCandidates) {\n          if (candidate.candidate != null) {\n            _logger.i(\"adding $candidate\");\n            await session.peerConnection?.addCandidate(candidate);\n          }\n        }\n        session.remoteCandidates.clear();\n      }\n\n      await Future.delayed(const Duration(milliseconds: 500));\n\n      String? sdpUsed = \"\";\n      session.peerConnection\n          ?.getLocalDescription()\n          .then((value) => sdpUsed = value?.sdp.toString());\n\n      Timer(const Duration(milliseconds: 500), () {\n        var dialogParams = DialogParams(\n            attach: false,\n            audio: true,\n            callID: callId,\n            callerIdName: callerName,\n            callerIdNumber: callerNumber,\n            clientState: clientState,\n            destinationNumber: destinationNumber,\n            remoteCallerIdName: \"\",\n            screenShare: false,\n            useStereo: false,\n            userVariables: [],\n            video: false,\n            customHeaders: customHeaders);\n        var inviteParams = InviteParams(\n            dialogParams: dialogParams,\n            sdp: sdpUsed,\n            sessid: sessionId,\n            userAgent: \"Flutter-1.0\");\n        var inviteMessage = InviteAnswerMessage(\n            id: const Uuid().v4(),\n            jsonrpc: JsonRPCConstant.jsonrpc,\n            method: SocketMethod.INVITE,\n            params: inviteParams);\n\n        String jsonInviteMessage = jsonEncode(inviteMessage);\n\n        _send(jsonInviteMessage);\n      });\n    } catch (e) {\n      _logger.e(\"Peer :: $e\");\n    }\n  }\n\n  void remoteSessionReceived(String sdp) async {\n    await _sessions[_selfId]\n        ?.peerConnection\n        ?.setRemoteDescription(RTCSessionDescription(sdp, \"answer\"));\n  }\n\n  void accept(\n      String callerName,\n      String callerNumber,\n      String destinationNumber,\n      String clientState,\n      String callId,\n      IncomingInviteParams invite,\n      Map<String, String> customHeaders,bool isAttach) async {\n    var sessionId = _selfId;\n    Session session = await _createSession(null,\n        peerId: \"0\", sessionId: sessionId, media: \"audio\");\n    _sessions[sessionId] = session;\n\n    await session.peerConnection\n        ?.setRemoteDescription(RTCSessionDescription(invite.sdp, \"offer\"));\n\n    _createAnswer(session, \"audio\", callerName, callerNumber, destinationNumber,\n        clientState, callId, customHeaders,isAttach);\n\n    onCallStateChange?.call(session, CallState.active);\n  }\n\n  Future<void> _createAnswer(\n      Session session,\n      String media,\n      String callerName,\n      String callerNumber,\n      String destinationNumber,\n      String clientState,\n      String callId,\n      Map<String, String> customHeaders,bool isAttach) async {\n    try {\n      session.peerConnection?.onIceCandidate = (candidate) async {\n        if (session.peerConnection != null) {\n          _logger.i(\"Peer :: Add Ice Candidate!\");\n          if (candidate.candidate != null) {\n            await session.peerConnection?.addCandidate(candidate);\n          }\n        } else {\n          session.remoteCandidates.add(candidate);\n        }\n      };\n\n      RTCSessionDescription s =\n          await session.peerConnection!.createAnswer(_dcConstraints);\n      await session.peerConnection!.setLocalDescription(s);\n\n      await Future.delayed(const Duration(milliseconds: 500));\n\n      String? sdpUsed = \"\";\n      session.peerConnection\n          ?.getLocalDescription()\n          .then((value) => sdpUsed = value?.sdp.toString());\n\n      Timer(const Duration(milliseconds: 500), () {\n        var dialogParams = DialogParams(\n            attach: false,\n            audio: true,\n            callID: callId,\n            callerIdName: callerNumber,\n            callerIdNumber: callerNumber,\n            clientState: clientState,\n            destinationNumber: destinationNumber,\n            remoteCallerIdName: \"\",\n            screenShare: false,\n            useStereo: false,\n            userVariables: [],\n            video: false,\n            customHeaders: customHeaders);\n        var inviteParams = InviteParams(\n            dialogParams: dialogParams,\n            sdp: sdpUsed,\n            sessid: session.sid,\n            userAgent: \"Flutter-1.0\");\n        var answerMessage = InviteAnswerMessage(\n            id: const Uuid().v4(),\n            jsonrpc: JsonRPCConstant.jsonrpc,\n            method: SocketMethod.ANSWER,\n            params: inviteParams);\n\n        String jsonAnswerMessage = jsonEncode(answerMessage);\n        _send(jsonAnswerMessage);\n      });\n    } catch (e) {\n      _logger.e(\"Peer :: $e\");\n    }\n  }\n\n  void closeSession() {\n    var sess = _sessions[_selfId];\n    if (sess != null) {\n      _logger.d(\"Session end success\");\n      _closeSession(sess);\n    } else {\n      _logger.d(\"Session end failed\");\n    }\n  }\n\n  Future<MediaStream> createStream(String media) async {\n    final Map<String, dynamic> mediaConstraints = {\n      'audio': true,\n      'video': false\n    };\n\n    MediaStream stream =\n        await navigator.mediaDevices.getUserMedia(mediaConstraints);\n    onLocalStream?.call(stream);\n    return stream;\n  }\n\n  Future<Session> _createSession(Session? session,\n      {required String peerId,\n      required String sessionId,\n      required String media}) async {\n    var newSession = session ?? Session(sid: sessionId, pid: peerId);\n    if (media != 'data') _localStream = await createStream(media);\n\n    RTCPeerConnection peerConnection = await createPeerConnection({\n      ..._iceServers,\n      ...{'sdpSemantics': sdpSemantics}\n    }, _dcConstraints);\n    if (media != 'data') {\n      switch (sdpSemantics) {\n        case 'plan-b':\n          peerConnection.onAddStream = (MediaStream stream) {\n            onAddRemoteStream?.call(newSession, stream);\n            _remoteStreams.add(stream);\n          };\n          await peerConnection.addStream(_localStream!);\n          break;\n        case 'unified-plan':\n          // Unified-Plan\n          peerConnection.onTrack = (event) {\n            if (event.track.kind == 'video') {\n              onAddRemoteStream?.call(newSession, event.streams[0]);\n            } else if (event.track.kind == 'audio') {\n              onAddRemoteStream?.call(newSession, event.streams[0]);\n            }\n          };\n          _localStream!.getTracks().forEach((track) {\n            peerConnection.addTrack(track, _localStream!);\n          });\n          break;\n      }\n    }\n    peerConnection.onIceCandidate = (candidate) async {\n      if (!candidate.candidate.toString().contains(\"127.0.0.1\")) {\n        _logger.i(\"Peer :: Adding ICE candidate :: ${candidate.toString()}\");\n        peerConnection.addCandidate(candidate);\n      } else {\n        _logger.i(\"Peer :: Local candidate skipped!\");\n      }\n      if (candidate.candidate == null) {\n        _logger.i(\"Peer :: onIceCandidate: complete!\");\n        return;\n      }\n    };\n\n    peerConnection.onIceConnectionState = (state) {\n      _logger.i(\"Peer :: ICE Connection State change :: $state\");\n      switch (state) {\n        case RTCIceConnectionState.RTCIceConnectionStateFailed:\n          peerConnection.restartIce();\n          return;\n        default:\n          return;\n      }\n    };\n\n    peerConnection.onRemoveStream = (stream) {\n      onRemoveRemoteStream?.call(newSession, stream);\n      _remoteStreams.removeWhere((it) {\n        return (it.id == stream.id);\n      });\n    };\n\n    peerConnection.onDataChannel = (channel) {\n      _addDataChannel(newSession, channel);\n    };\n\n    newSession.peerConnection = peerConnection;\n    return newSession;\n  }\n\n  void _addDataChannel(Session session, RTCDataChannel channel) {\n    channel.onDataChannelState = (e) {};\n    channel.onMessage = (RTCDataChannelMessage data) {\n      onDataChannelMessage?.call(session, channel, data);\n    };\n    session.dc = channel;\n    onDataChannel?.call(session, channel);\n  }\n\n  /*Future<void> _createDataChannel(Session session,\n      {label = 'fileTransfer'}) async {\n    RTCDataChannelInit dataChannelDict = RTCDataChannelInit()\n      ..maxRetransmits = 30;\n    RTCDataChannel channel =\n        await session.peerConnection!.createDataChannel(label, dataChannelDict);\n    _addDataChannel(session, channel);\n  }*/\n\n  _send(event) {\n    _socket.send(event);\n  }\n\n  Future<void> _cleanSessions() async {\n    if (_localStream != null) {\n      _localStream!.getTracks().forEach((element) async {\n        await element.stop();\n      });\n      await _localStream!.dispose();\n      _localStream = null;\n    }\n    _sessions.forEach((key, sess) async {\n      await sess.peerConnection?.close();\n      await sess.dc?.close();\n    });\n    _sessions.clear();\n  }\n\n  /*void _closeSessionByPeerId(String peerId) {\n    Session? session;\n    _sessions.removeWhere((String key, Session sess) {\n      var ids = key.split('-');\n      session = sess;\n      return peerId == ids[0] || peerId == ids[1];\n    });\n    if (session != null) {\n      _closeSession(session!);\n      onCallStateChange?.call(session!, CallState.CallStateBye);\n    }\n  }*/\n\n  Future<void> _closeSession(Session session) async {\n    _localStream?.getTracks().forEach((element) async {\n      await element.stop();\n    });\n    await _localStream?.dispose();\n    _localStream = null;\n\n    await session.peerConnection?.close();\n    await session.dc?.close();\n  }\n}\n\nint randomBetween(int from, int to) {\n  if (from > to) throw Exception('$from cannot be > $to');\n  var rand = Random();\n  return ((to - from) * rand.nextDouble()).toInt() + from;\n}\n\nString randomString(int length, {int from = 33, int to = 126}) {\n  return String.fromCharCodes(\n      List.generate(length, (index) => randomBetween(from, to)));\n}\n\nString randomNumeric(int length) => randomString(length, from: 48, to: 57);\n"
        }
    ]
}