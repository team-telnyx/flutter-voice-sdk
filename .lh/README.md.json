{
    "sourceFile": "README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1724322403635,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1724322414887,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,436 @@\n+![Pub Version](https://img.shields.io/pub/v/telnyx_webrtc?color=blue&logo=telnyx)\n+[![Flutter Test](https://github.com/team-telnyx/telnyx-webrtc-flutter/actions/workflows/unit_tests.yml/badge.svg)](https://github.com/team-telnyx/telnyx-webrtc-flutter/actions/workflows/unit_tests.yml)\n+\n+# Telnyx Flutter Voice SDK\n+\n+\n+Enable Telnyx real-time communication services on Flutter applications (Android / iOS / Web) :telephone_receiver: :fire:\n+\n+## Features\n+- [x] Create / Receive calls\n+- [x] Hold calls\n+- [x] Mute calls\n+- [x] Dual Tone Multi Frequency\n+\n+## Usage\n+\n+### SIP Credentials\n+In order to start making and receiving calls using the TelnyxRTC SDK you will need to get SIP Credentials:\n+\n+![Screenshot 2022-07-15 at 13 51 45](https://user-images.githubusercontent.com/9112652/179226614-f0477f38-6131-4cef-9c7a-3366f23a89b6.png)\n+\n+1. Access to https://portal.telnyx.com/\n+2. Sign up for a Telnyx Account.\n+3. Create a Credential Connection to configure how you connect your calls.\n+4. Create an Outbound Voice Profile to configure your outbound call settings and assign it to your Credential Connection.\n+\n+For more information on how to generate SIP credentials check the [Telnyx WebRTC quickstart guide](https://developers.telnyx.com/docs/v2/webrtc/quickstart).\n+\n+### Platform Specific Configuration\n+\n+## Android\n+If you are implementing the SDK into an Android application it is important to remember to add the following permissions to your AndroidManifest in order to allow Audio and Internet permissions:\n+\n+```xml\n+    <uses-permission android:name=\"android.permission.INTERNET\"/>\n+    <uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\n+    <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" />\n+```\n+\n+## iOS\n+on the iOS platform, you need to add the microphone permission to your Info.plist file:\n+\n+```xml\n+    <key>NSMicrophoneUsageDescription</key>\n+    <string>$(PRODUCT_NAME) Microphone Usage!</string>\n+```\n+\n+### Telnyx Client\n+TelnyxClient() is the core class of the SDK, and can be used to connect to our backend socket connection, create calls, check state and disconnect, etc.\n+\n+Once an instance is created, you can call the .connect() method to connect to the socket. An error will appear as a socket response if there is no network available:\n+\n+```dart\n+    TelnyxClient _telnyxClient = TelnyxClient();\n+    _telnyxClient.connect();\n+```\n+\n+### Logging into Telnyx Client\n+To log into the Telnyx WebRTC client, you'll need to authenticate using a Telnyx SIP Connection. Follow our [quickstart guide](https://developers.telnyx.com/docs/v2/webrtc/quickstart) to create **JWTs** (JSON Web Tokens) to authenticate. To log in with a token we use the tokinLogin() method. You can also authenticate directly with the SIP Connection `username` and `password` with the credentialLogin() method:\n+\n+ ```dart\n+    _telnyxClient.tokenLogin(tokenConfig)\n+                     //OR\n+    _telnyxClient.credentialLogin(credentialConfig)             \n+ ```\n+\n+**Note:** **tokenConfig** and **credentialConfig** are simple classes that represent login settings for the client to use. They look like this:\n+\n+ ```dart\n+ /// Creates an instance of CredentialConfig which can be used to log in\n+///\n+/// Uses the [sipUser] and [sipPassword] fields to log in\n+/// [sipCallerIDName] and [sipCallerIDNumber] will be the Name and Number associated\n+/// [notificationToken] is the token used to register the device for notifications if required (FCM or APNS)\n+/// The [autoReconnect] flag decided whether or not to attempt a reconnect (3 attempts) in the case of a login failure with\n+/// legitimate credentials\n+class CredentialConfig {\n+  CredentialConfig(this.sipUser, this.sipPassword, this.sipCallerIDName,\n+      this.sipCallerIDNumber, this.notificationToken, this.autoReconnect);\n+\n+  final String sipUser;\n+  final String sipPassword;\n+  final String sipCallerIDName;\n+  final String sipCallerIDNumber;\n+  final String? notificationToken;\n+  final bool? autoReconnect;\n+}\n+\n+/// Creates an instance of TokenConfig which can be used to log in\n+///\n+/// Uses the [sipToken] field to log in\n+/// [sipCallerIDName] and [sipCallerIDNumber] will be the Name and Number associated\n+/// [notificationToken] is the token used to register the device for notifications if required (FCM or APNS)\n+/// The [autoReconnect] flag decided whether or not to attempt a reconnect (3 attempts) in the case of a login failure with\n+/// a legitimate token\n+class TokenConfig {\n+  TokenConfig(this.sipToken, this.sipCallerIDName, this.sipCallerIDNumber,\n+      this.notificationToken, this.autoReconnect);\n+\n+  final String sipToken;\n+  final String sipCallerIDName;\n+  final String sipCallerIDNumber;\n+  final String? notificationToken;\n+  final bool? autoReconnect;\n+}\n+ ```\n+ \n+###  Adding push notifications - Android platform\n+The Android platform makes use of Firebase Cloud Messaging in order to deliver push notifications. To receive notifications when receiving calls on your Android mobile device you will have to enable Firebase Cloud Messaging within your application.\n+For a detailed tutorial, please visit our official [Push Notification Docs](https://developers.telnyx.com/docs/v2/webrtc/push-notifications?type=Android).\n+The Demo app uses the [FlutterCallkitIncoming](https://pub.dev/packages/flutter_callkit_incoming) plugin to show incoming calls. To show a notification when receiving a call, you can follow the steps below:\n+1. Listen for Background Push Notifications, Implement the `FirebaseMessaging.onBackgroundMessage` method in your `main` method\n+```dart\n+\n+@pragma('vm:entry-point')\n+Future<void> main() async {\n+    WidgetsFlutterBinding.ensureInitialized();\n+\n+    if (defaultTargetPlatform == TargetPlatform.android) {\n+      // Android Only - Push Notifications\n+        await Firebase.initializeApp();\n+        FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);\n+      \n+        await FirebaseMessaging.instance\n+                .setForegroundNotificationPresentationOptions(\n+         alert: true,\n+         badge: true,\n+         sound: true,\n+      );\n+    }\n+      runApp(const MyApp());\n+}\n+```\n+\n+2. Optionally Add the `metadata` to CallKitParams `extra` field\n+```dart\n+\n+    static Future showNotification(RemoteMessage message)  {\n+      CallKitParams callKitParams = CallKitParams(\n+        android:...,\n+          ios:...,\n+          extra: message.data,\n+      )\n+      await FlutterCallkitIncoming.showCallkitIncoming(callKitParams);\n+    }\n+```\n+\n+\n+3. Handle the push notification in the `_firebaseMessagingBackgroundHandler` method\n+```dart\n+\n+Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {\n+      //show notifcation\n+      showNotification(message);\n+      \n+      //Listen to action from FlutterCallkitIncoming\n+      FlutterCallkitIncoming.onEvent.listen((CallEvent? event) async {\n+       switch (event!.event) {\n+        case Event.actionCallAccept:\n+         // Set the telnyx metadata for access when the app comes to foreground\n+         TelnyxClient.setPushMetaData(\n+                 message.data, isAnswer: true, isDecline: false);\n+         break;\n+        case Event.actionCallDecline:\n+        /*\n+        * When the user declines the call from the push notification, the app will no longer be visible, and we have to\n+        * handle the endCall user here.\n+        * Login to the TelnyxClient and end the call\n+        * */\n+          ...\n+       }});\n+}\n+\n+\n+```\n+\n+4. Use the `TelnyxClient.getPushMetaData()` method to retrieve the metadata when the app comes to the foreground. This data is only available on 1st access and becomes `null` afterward.\n+```dart\n+    Future<void> _handlePushNotification() async {\n+       final  data = await TelnyxClient.getPushMetaData();\n+       PushMetaData? pushMetaData = PushMetaData.fromJson(data);\n+      if (pushMetaData != null) {\n+        _telnyxClient.handlePushNotification(pushMetaData, credentialConfig, tokenConfig);\n+      }\n+    }\n+```\n+\n+5. To Handle push calls on foreground, Listen for Call Events and invoke the `handlePushNotification` method\n+```dart\n+FlutterCallkitIncoming.onEvent.listen((CallEvent? event) {\n+   switch (event!.event) {\n+   case Event.actionCallIncoming:\n+   // retrieve the push metadata from extras\n+   final data = await TelnyxClient.getPushData();\n+   ...\n+  _telnyxClient.handlePushNotification(pushMetaData, credentialConfig, tokenConfig);\n+    break;\n+   case Event.actionCallStart:\n+    ....\n+   break;\n+   case Event.actionCallAccept:\n+     ...\n+   logger.i('Call Accepted Attach Call');\n+   break;\n+   });\n+```\n+\n+#### Best Practices for Push Notifications on Android \n+1. Request for Notification Permissions for android 13+ devices to show push notifications. More information can be found [here](https://developer.android.com/develop/ui/views/notifications/notification-permission)\n+2. Push Notifications only work in foreground for apps that are run in `debug` mode (You will not receive push notifications when you terminate the app while running in debug mode).\n+3. On Foreground calls, you can use the `FirebaseMessaging.onMessage.listen` method to listen for incoming calls and show a notification.\n+```dart\n+ FirebaseMessaging.onMessage.listen((RemoteMessage message) {\n+        TelnyxClient.setPushMetaData(message.data);\n+        NotificationService.showNotification(message);\n+        mainViewModel.callFromPush = true;\n+      });\n+```\n+4. To handle push notifications on the background,  use the `FirebaseMessaging.onBackgroundMessage` method to listen for incoming calls and show a notification and make sure to set the ` TelnyxClient.setPushMetaData` when user answers the call.\n+```dart \n+ TelnyxClient.setPushMetaData(\n+                 message.data, isAnswer: true, isDecline: false);\n+```\n+5. When you call the `telnyxClient.handlePushNotification` it connects to the `telnyxClient`, make sure not to call the `telnyxClient.connect()` method after this. e.g an Edge case might be if you call `telnyxClient.connect()` on Widget `init` method it\n+   will always call the `connect` method\n+\n+\n+6. Early Answer/Decline : Users may answer/decline the call too early before a socket connection is established. To handle this situation,\n+assert if the `IncomingInviteParams` is not null and only accept with below logic\n+```dart\n+\n+  bool waitingForInvite = false;\n+\n+  if (_incomingInvite != null) {\n+\n+  }\n+\n+\n+\n+```\n+\n+\n+ \n+### Adding push notifications - iOS platform\n+The iOS Platform makes use of the Apple Push Notification Service (APNS) and Pushkit in order to deliver and receive push notifications\n+For a detailed tutorial, please visit our official [Push Notification Docs](https://developers.telnyx.com/docs/v2/webrtc/push-notifications?lang=ios)\n+1. Register/Invalidate the push device token for iOS\n+```swift\n+        func pushRegistry(_ registry: PKPushRegistry, didUpdate credentials: PKPushCredentials, for type: PKPushType) {\n+            print(credentials.token)\n+            let deviceToken = credentials.token.map { String(format: \"%02x\", $0) }.joined()\n+            //Save deviceToken to your server\n+            SwiftFlutterCallkitIncomingPlugin.sharedInstance?.setDevicePushTokenVoIP(deviceToken)\n+        }\n+        \n+        func pushRegistry(_ registry: PKPushRegistry, didInvalidatePushTokenFor type: PKPushType) {\n+            SwiftFlutterCallkitIncomingPlugin.sharedInstance?.setDevicePushTokenVoIP(\"\")\n+        }\n+```\n+\n+2. For foreground calls to work, you need to register with callkit on the restorationHandler delegate function. You can also choose to register with callkit using iOS official documentation on\n+   [CallKit](https://developer.apple.com/documentation/callkit/).\n+```swift\n+  override func application(_ application: UIApplication,\n+                                  continue userActivity: NSUserActivity,\n+                                  restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {\n+                                  \n+            let nameCaller = handleObj.getDecryptHandle()[\"nameCaller\"] as? String ?? \"\"\n+            let handle = handleObj.getDecryptHandle()[\"handle\"] as? String ?? \"\"\n+            let data = flutter_callkit_incoming.Data(id: UUID().uuidString, nameCaller: nameCaller, handle: handle, type: isVideo ? 1 : 0)\n+            //set more data...\n+            data.nameCaller = \"dummy\"\n+            SwiftFlutterCallkitIncomingPlugin.sharedInstance?.startCall(data, fromPushKit: true)\n+         \n+         }                         \n+```\n+3. Listen for incoming calls in AppDelegate.swift class\n+```swift \n+    func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -> Void) {\n+            print(\"didReceiveIncomingPushWith\")\n+            guard type == .voIP else { return }\n+            \n+            if let metadata = payload.dictionaryPayload[\"metadata\"] as? [String: Any] {\n+                var callID = UUID.init().uuidString\n+                if let newCallId = (metadata[\"call_id\"] as? String),\n+                   !newCallId.isEmpty {\n+                    callID = newCallId\n+                }\n+                let callerName = (metadata[\"caller_name\"] as? String) ?? \"\"\n+                let callerNumber = (metadata[\"caller_number\"] as? String) ?? \"\"\n+                \n+                let id = payload.dictionaryPayload[\"call_id\"] as? String ??  UUID().uuidString\n+                \n+                let data = flutter_callkit_incoming.Data(id: id, nameCaller: callerName, handle: callerNumber, type: isVideo ? 1 : 0)\n+                data.extra = payload.dictionaryPayload as NSDictionary\n+                data.normalHandle = 1              \n+                \n+                let caller = callerName.isEmpty ? (callerNumber.isEmpty ? \"Unknown\" : callerNumber) : callerName\n+                let uuid = UUID(uuidString: callID)\n+                \n+                data.uuid = uuid!.uuidString\n+                data.nameCaller = caller\n+                \n+                SwiftFlutterCallkitIncomingPlugin.sharedInstance?.showCallkitIncoming(data, fromPushKit: true)\n+            }\n+        }\n+```\n+\n+4. Listen for Call Events and invoke the `handlePushNotification` method\n+```dart\n+   FlutterCallkitIncoming.onEvent.listen((CallEvent? event) {\n+   switch (event!.event) {\n+   case Event.actionCallIncoming:\n+   // retrieve the push metadata from extras\n+    PushMetaData? pushMetaData = PushMetaData.fromJson(event.body['extra']['metadata']);\n+    _telnyxClient.handlePushNotification(pushMetaData, credentialConfig, tokenConfig);\n+    break;\n+   case Event.actionCallStart:\n+    ....\n+   break;\n+   case Event.actionCallAccept:\n+     ...\n+   logger.i('Call Accepted Attach Call');\n+   break;\n+   });\n+```\n+\n+\n+\n+#### Best Practices for Push Notifications on iOS\n+1. Push Notifications only work in foreground for apps that are run in `debug` mode (You will not receive push notifications when you terminate the app while running in debug mode). Make sure you are in `release` mode. Preferably test using Testfight or Appstore.\n+To test if push notifications are working, disconnect the telnyx client (while app is in foreground) and make a call to the device. You should receive a push notification.\n+\n+\n+### Creating a call invitation\n+In order to make a call invitation, we first create an instance of the Call class with the .call instance. This creates a Call class which can be used to interact with calls (invite, accept, decline, etc).\n+To then send an invite, we can use the .newInvite() method which requires you to provide your callerName, callerNumber, the destinationNumber (or SIP credential), and your clientState (any String value).\n+\n+```dart\n+    _telnyxClient\n+        .call\n+        .newInvite(\"callerName\", \"000000000\", destination, \"State\");\n+```\n+\n+### Accepting a call\n+In order to be able to accept a call, we first need to listen for invitations. We do this by getting the Telnyx Socket Response callbacks:\n+\n+```dart\n+ // Observe Socket Messages Received\n+_telnyxClient.onSocketMessageReceived = (TelnyxMessage message) {\n+  switch (message.socketMethod) {\n+        case SocketMethod.CLIENT_READY:\n+        {\n+           // Fires once client has correctly been setup and logged into, you can now make calls. \n+           break;\n+        }\n+        case SocketMethod.LOGIN:\n+        {\n+            // Handle a successful login - Update UI or Navigate to new screen, etc. \n+            break;\n+        }\n+        case SocketMethod.INVITE:\n+        {\n+            // Handle an invitation Update UI or Navigate to new screen, etc. \n+            // Then, through an answer button of some kind we can accept the call with:\n+            _incomingInvite = message.message.inviteParams;\n+            _telnyxClient.createCall().acceptCall(\n+                _incomingInvite, \"callerName\", \"000000000\", \"State\");\n+            break;\n+        }\n+        case SocketMethod.ANSWER:\n+        {\n+           // Handle a received call answer - Update UI or Navigate to new screen, etc.\n+          break;\n+        }\n+        case SocketMethod.BYE:\n+        {\n+           // Handle a call rejection or ending - Update UI or Navigate to new screen, etc.\n+           break;\n+      }\n+    }\n+    notifyListeners();\n+};\n+```\n+\n+We can then use this method to create a listener that listens for an invitation and, in this case, answers it straight away. A real implementation would be more suited to show some UI and allow manual accept / decline operations. \n+\n+### Decline / End Call\n+\n+In order to end a call, we can get a stored instance of Call and call the .endCall(callID) method. To decline an incoming call we first create the call with the .createCall() method and then call the .endCall(callID) method:\n+\n+```dart\n+    if (_ongoingCall) {\n+      _telnyxClient.call.endCall(_telnyxClient.call.callId);\n+    } else {\n+      _telnyxClient.createCall().endCall(_incomingInvite?.callID);\n+    }\n+```\n+\n+### DTMF (Dual Tone Multi Frequency)\n+\n+In order to send a DTMF message while on a call you can call the .dtmf(callID, tone), method where tone is a String value of the character you would like pressed:\n+\n+```dart\n+    _telnyxClient.call.dtmf(_telnyxClient.call.callId, tone);\n+```\n+\n+### Mute a call\n+\n+To mute a call, you can simply call the .onMuteUnmutePressed() method:\n+\n+```dart\n+    _telnyxClient.call.onMuteUnmutePressed();\n+```\n+\n+### Toggle loud speaker\n+\n+To toggle loud speaker, you can simply call .enableSpeakerPhone(bool):\n+\n+```dart\n+    _telnyxClient.call.enableSpeakerPhone(true);\n+```\n+\n+### Put a call on hold\n+\n+To put a call on hold, you can simply call the .onHoldUnholdPressed() method:\n+\n+```dart\n+    _telnyxClient.call.onHoldUnholdPressed();\n+```\n+\n+Questions? Comments? Building something rad? [Join our Slack channel](https://joinslack.telnyx.com/) and share.\n+\n+## License\n+\n+[`MIT Licence`](./LICENSE) © [Telnyx](https://github.com/team-telnyx)\n"
                },
                {
                    "date": 1724323103476,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -225,453 +225,52 @@\n    will always call the `connect` method\n \n \n 6. Early Answer/Decline : Users may answer/decline the call too early before a socket connection is established. To handle this situation,\n-assert if the `IncomingInviteParams` is not null and only accept with below logic\n+assert if the `IncomingInviteParams` is not null and only accept/decline if this is availalble. \n ```dart\n-\n   bool waitingForInvite = false;\n \n-  if (_incomingInvite != null) {\n+void accept() {\n \n-  }\n-\n-\n-\n-```\n-\n-\n- \n-### Adding push notifications - iOS platform\n-The iOS Platform makes use of the Apple Push Notification Service (APNS) and Pushkit in order to deliver and receive push notifications\n-For a detailed tutorial, please visit our official [Push Notification Docs](https://developers.telnyx.com/docs/v2/webrtc/push-notifications?lang=ios)\n-1. Register/Invalidate the push device token for iOS\n-```swift\n-        func pushRegistry(_ registry: PKPushRegistry, didUpdate credentials: PKPushCredentials, for type: PKPushType) {\n-            print(credentials.token)\n-            let deviceToken = credentials.token.map { String(format: \"%02x\", $0) }.joined()\n-            //Save deviceToken to your server\n-            SwiftFlutterCallkitIncomingPlugin.sharedInstance?.setDevicePushTokenVoIP(deviceToken)\n-        }\n-        \n-        func pushRegistry(_ registry: PKPushRegistry, didInvalidatePushTokenFor type: PKPushType) {\n-            SwiftFlutterCallkitIncomingPlugin.sharedInstance?.setDevicePushTokenVoIP(\"\")\n-        }\n-```\n-\n-2. For foreground calls to work, you need to register with callkit on the restorationHandler delegate function. You can also choose to register with callkit using iOS official documentation on\n-   [CallKit](https://developer.apple.com/documentation/callkit/).\n-```swift\n-  override func application(_ application: UIApplication,\n-                                  continue userActivity: NSUserActivity,\n-                                  restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {\n-                                  \n-            let nameCaller = handleObj.getDecryptHandle()[\"nameCaller\"] as? String ?? \"\"\n-            let handle = handleObj.getDecryptHandle()[\"handle\"] as? String ?? \"\"\n-            let data = flutter_callkit_incoming.Data(id: UUID().uuidString, nameCaller: nameCaller, handle: handle, type: isVideo ? 1 : 0)\n-            //set more data...\n-            data.nameCaller = \"dummy\"\n-            SwiftFlutterCallkitIncomingPlugin.sharedInstance?.startCall(data, fromPushKit: true)\n-         \n-         }                         \n-```\n-3. Listen for incoming calls in AppDelegate.swift class\n-```swift \n-    func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -> Void) {\n-            print(\"didReceiveIncomingPushWith\")\n-            guard type == .voIP else { return }\n-            \n-            if let metadata = payload.dictionaryPayload[\"metadata\"] as? [String: Any] {\n-                var callID = UUID.init().uuidString\n-                if let newCallId = (metadata[\"call_id\"] as? String),\n-                   !newCallId.isEmpty {\n-                    callID = newCallId\n-                }\n-                let callerName = (metadata[\"caller_name\"] as? String) ?? \"\"\n-                let callerNumber = (metadata[\"caller_number\"] as? String) ?? \"\"\n-                \n-                let id = payload.dictionaryPayload[\"call_id\"] as? String ??  UUID().uuidString\n-                \n-                let data = flutter_callkit_incoming.Data(id: id, nameCaller: callerName, handle: callerNumber, type: isVideo ? 1 : 0)\n-                data.extra = payload.dictionaryPayload as NSDictionary\n-                data.normalHandle = 1              \n-                \n-                let caller = callerName.isEmpty ? (callerNumber.isEmpty ? \"Unknown\" : callerNumber) : callerName\n-                let uuid = UUID(uuidString: callID)\n-                \n-                data.uuid = uuid!.uuidString\n-                data.nameCaller = caller\n-                \n-                SwiftFlutterCallkitIncomingPlugin.sharedInstance?.showCallkitIncoming(data, fromPushKit: true)\n-            }\n-        }\n-```\n-\n-4. Listen for Call Events and invoke the `handlePushNotification` method\n-```dart\n-   FlutterCallkitIncoming.onEvent.listen((CallEvent? event) {\n-   switch (event!.event) {\n-   case Event.actionCallIncoming:\n-   // retrieve the push metadata from extras\n-    PushMetaData? pushMetaData = PushMetaData.fromJson(event.body['extra']['metadata']);\n-    _telnyxClient.handlePushNotification(pushMetaData, credentialConfig, tokenConfig);\n-    break;\n-   case Event.actionCallStart:\n-    ....\n-   break;\n-   case Event.actionCallAccept:\n-     ...\n-   logger.i('Call Accepted Attach Call');\n-   break;\n-   });\n-```\n-\n-\n-\n-#### Best Practices for Push Notifications on iOS\n-1. Push Notifications only work in foreground for apps that are run in `debug` mode (You will not receive push notifications when you terminate the app while running in debug mode). Make sure you are in `release` mode. Preferably test using Testfight or Appstore.\n-To test if push notifications are working, disconnect the telnyx client (while app is in foreground) and make a call to the device. You should receive a push notification.\n-\n-\n-### Creating a call invitation\n-In order to make a call invitation, we first create an instance of the Call class with the .call instance. This creates a Call class which can be used to interact with calls (invite, accept, decline, etc).\n-To then send an invite, we can use the .newInvite() method which requires you to provide your callerName, callerNumber, the destinationNumber (or SIP credential), and your clientState (any String value).\n-\n-```dart\n-    _telnyxClient\n-        .call\n-        .newInvite(\"callerName\", \"000000000\", destination, \"State\");\n-```\n-\n-### Accepting a call\n-In order to be able to accept a call, we first need to listen for invitations. We do this by getting the Telnyx Socket Response callbacks:\n-\n-```dart\n- // Observe Socket Messages Received\n-_telnyxClient.onSocketMessageReceived = (TelnyxMessage message) {\n-  switch (message.socketMethod) {\n-        case SocketMethod.CLIENT_READY:\n-        {\n-           // Fires once client has correctly been setup and logged into, you can now make calls. \n-           break;\n-        }\n-        case SocketMethod.LOGIN:\n-        {\n-            // Handle a successful login - Update UI or Navigate to new screen, etc. \n-            break;\n-        }\n-        case SocketMethod.INVITE:\n-        {\n-            // Handle an invitation Update UI or Navigate to new screen, etc. \n-            // Then, through an answer button of some kind we can accept the call with:\n-            _incomingInvite = message.message.inviteParams;\n-            _telnyxClient.createCall().acceptCall(\n-                _incomingInvite, \"callerName\", \"000000000\", \"State\");\n-            break;\n-        }\n-        case SocketMethod.ANSWER:\n-        {\n-           // Handle a received call answer - Update UI or Navigate to new screen, etc.\n-          break;\n-        }\n-        case SocketMethod.BYE:\n-        {\n-           // Handle a call rejection or ending - Update UI or Navigate to new screen, etc.\n-           break;\n-      }\n-    }\n-    notifyListeners();\n-};\n-```\n-\n-We can then use this method to create a listener that listens for an invitation and, in this case, answers it straight away. A real implementation would be more suited to show some UI and allow manual accept / decline operations. \n-\n-### Decline / End Call\n-\n-In order to end a call, we can get a stored instance of Call and call the .endCall(callID) method. To decline an incoming call we first create the call with the .createCall() method and then call the .endCall(callID) method:\n-\n-```dart\n-    if (_ongoingCall) {\n-      _telnyxClient.call.endCall(_telnyxClient.call.callId);\n+if (_incomingInvite != null) {\n+  // accept the call if the incomingInvite arrives on time \n+      _currentCall = _telnyxClient.acceptCall(\n+          _incomingInvite!, _localName, _localNumber, \"State\");\n     } else {\n-      _telnyxClient.createCall().endCall(_incomingInvite?.callID);\n+      // set waitingForInvite to true if we have an early accept\n+      waitingForInvite = true;\n     }\n-```\n-\n-### DTMF (Dual Tone Multi Frequency)\n-\n-In order to send a DTMF message while on a call you can call the .dtmf(callID, tone), method where tone is a String value of the character you would like pressed:\n-\n-```dart\n-    _telnyxClient.call.dtmf(_telnyxClient.call.callId, tone);\n-```\n-\n-### Mute a call\n-\n-To mute a call, you can simply call the .onMuteUnmutePressed() method:\n-\n-```dart\n-    _telnyxClient.call.onMuteUnmutePressed();\n-```\n-\n-### Toggle loud speaker\n-\n-To toggle loud speaker, you can simply call .enableSpeakerPhone(bool):\n-\n-```dart\n-    _telnyxClient.call.enableSpeakerPhone(true);\n-```\n-\n-### Put a call on hold\n-\n-To put a call on hold, you can simply call the .onHoldUnholdPressed() method:\n-\n-```dart\n-    _telnyxClient.call.onHoldUnholdPressed();\n-```\n-\n-Questions? Comments? Building something rad? [Join our Slack channel](https://joinslack.telnyx.com/) and share.\n-\n-## License\n-\n-[`MIT Licence`](./LICENSE) © [Telnyx](https://github.com/team-telnyx)\n-![Pub Version](https://img.shields.io/pub/v/telnyx_webrtc?color=blue&logo=telnyx)\n-[![Flutter Test](https://github.com/team-telnyx/telnyx-webrtc-flutter/actions/workflows/unit_tests.yml/badge.svg)](https://github.com/team-telnyx/telnyx-webrtc-flutter/actions/workflows/unit_tests.yml)\n-\n-# Telnyx Flutter Voice SDK\n-\n-\n-Enable Telnyx real-time communication services on Flutter applications (Android / iOS / Web) :telephone_receiver: :fire:\n-\n-## Features\n-- [x] Create / Receive calls\n-- [x] Hold calls\n-- [x] Mute calls\n-- [x] Dual Tone Multi Frequency\n-\n-## Usage\n-\n-### SIP Credentials\n-In order to start making and receiving calls using the TelnyxRTC SDK you will need to get SIP Credentials:\n-\n-![Screenshot 2022-07-15 at 13 51 45](https://user-images.githubusercontent.com/9112652/179226614-f0477f38-6131-4cef-9c7a-3366f23a89b6.png)\n-\n-1. Access to https://portal.telnyx.com/\n-2. Sign up for a Telnyx Account.\n-3. Create a Credential Connection to configure how you connect your calls.\n-4. Create an Outbound Voice Profile to configure your outbound call settings and assign it to your Credential Connection.\n-\n-For more information on how to generate SIP credentials check the [Telnyx WebRTC quickstart guide](https://developers.telnyx.com/docs/v2/webrtc/quickstart).\n-\n-### Platform Specific Configuration\n-\n-## Android\n-If you are implementing the SDK into an Android application it is important to remember to add the following permissions to your AndroidManifest in order to allow Audio and Internet permissions:\n-\n-```xml\n-    <uses-permission android:name=\"android.permission.INTERNET\"/>\n-    <uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\n-    <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" />\n-```\n-\n-## iOS\n-on the iOS platform, you need to add the microphone permission to your Info.plist file:\n-\n-```xml\n-    <key>NSMicrophoneUsageDescription</key>\n-    <string>$(PRODUCT_NAME) Microphone Usage!</string>\n-```\n-\n-### Telnyx Client\n-TelnyxClient() is the core class of the SDK, and can be used to connect to our backend socket connection, create calls, check state and disconnect, etc.\n-\n-Once an instance is created, you can call the .connect() method to connect to the socket. An error will appear as a socket response if there is no network available:\n-\n-```dart\n-    TelnyxClient _telnyxClient = TelnyxClient();\n-    _telnyxClient.connect();\n-```\n-\n-### Logging into Telnyx Client\n-To log into the Telnyx WebRTC client, you'll need to authenticate using a Telnyx SIP Connection. Follow our [quickstart guide](https://developers.telnyx.com/docs/v2/webrtc/quickstart) to create **JWTs** (JSON Web Tokens) to authenticate. To log in with a token we use the tokinLogin() method. You can also authenticate directly with the SIP Connection `username` and `password` with the credentialLogin() method:\n-\n- ```dart\n-    _telnyxClient.tokenLogin(tokenConfig)\n-                     //OR\n-    _telnyxClient.credentialLogin(credentialConfig)             \n- ```\n-\n-**Note:** **tokenConfig** and **credentialConfig** are simple classes that represent login settings for the client to use. They look like this:\n-\n- ```dart\n- /// Creates an instance of CredentialConfig which can be used to log in\n-///\n-/// Uses the [sipUser] and [sipPassword] fields to log in\n-/// [sipCallerIDName] and [sipCallerIDNumber] will be the Name and Number associated\n-/// [notificationToken] is the token used to register the device for notifications if required (FCM or APNS)\n-/// The [autoReconnect] flag decided whether or not to attempt a reconnect (3 attempts) in the case of a login failure with\n-/// legitimate credentials\n-class CredentialConfig {\n-  CredentialConfig(this.sipUser, this.sipPassword, this.sipCallerIDName,\n-      this.sipCallerIDNumber, this.notificationToken, this.autoReconnect);\n-\n-  final String sipUser;\n-  final String sipPassword;\n-  final String sipCallerIDName;\n-  final String sipCallerIDNumber;\n-  final String? notificationToken;\n-  final bool? autoReconnect;\n }\n \n-/// Creates an instance of TokenConfig which can be used to log in\n-///\n-/// Uses the [sipToken] field to log in\n-/// [sipCallerIDName] and [sipCallerIDNumber] will be the Name and Number associated\n-/// [notificationToken] is the token used to register the device for notifications if required (FCM or APNS)\n-/// The [autoReconnect] flag decided whether or not to attempt a reconnect (3 attempts) in the case of a login failure with\n-/// a legitimate token\n-class TokenConfig {\n-  TokenConfig(this.sipToken, this.sipCallerIDName, this.sipCallerIDNumber,\n-      this.notificationToken, this.autoReconnect);\n \n-  final String sipToken;\n-  final String sipCallerIDName;\n-  final String sipCallerIDNumber;\n-  final String? notificationToken;\n-  final bool? autoReconnect;\n-}\n- ```\n- \n-###  Adding push notifications - Android platform\n-The Android platform makes use of Firebase Cloud Messaging in order to deliver push notifications. To receive notifications when receiving calls on your Android mobile device you will have to enable Firebase Cloud Messaging within your application.\n-For a detailed tutorial, please visit our official [Push Notification Docs](https://developers.telnyx.com/docs/v2/webrtc/push-notifications?type=Android).\n-The Demo app uses the [FlutterCallkitIncoming](https://pub.dev/packages/flutter_callkit_incoming) plugin to show incoming calls. To show a notification when receiving a call, you can follow the steps below:\n-1. Listen for Background Push Notifications, Implement the `FirebaseMessaging.onBackgroundMessage` method in your `main` method\n-```dart\n+ _telnyxClient.onSocketMessageReceived = (TelnyxMessage message) {\n+      switch (message.socketMethod) {\n+        ...\n+        case SocketMethod.INVITE:\n+          {\n+            if (callFromPush) {\n+              // For early accept of call\n+              if (waitingForInvite) {\n+                //accept the call\n+                accept();\n+                waitingForInvite = false;\n+              }\n+              callFromPush = false;\n+            }\n \n-@pragma('vm:entry-point')\n-Future<void> main() async {\n-    WidgetsFlutterBinding.ensureInitialized();\n-\n-    if (defaultTargetPlatform == TargetPlatform.android) {\n-      // Android Only - Push Notifications\n-        await Firebase.initializeApp();\n-        FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);\n-      \n-        await FirebaseMessaging.instance\n-                .setForegroundNotificationPresentationOptions(\n-         alert: true,\n-         badge: true,\n-         sound: true,\n-      );\n-    }\n-      runApp(const MyApp());\n-}\n-```\n-\n-2. Optionally Add the `metadata` to CallKitParams `extra` field\n-```dart\n-\n-    static Future showNotification(RemoteMessage message)  {\n-      CallKitParams callKitParams = CallKitParams(\n-        android:...,\n-          ios:...,\n-          extra: message.data,\n-      )\n-      await FlutterCallkitIncoming.showCallkitIncoming(callKitParams);\n-    }\n-```\n-\n-\n-3. Handle the push notification in the `_firebaseMessagingBackgroundHandler` method\n-```dart\n-\n-Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {\n-      //show notifcation\n-      showNotification(message);\n-      \n-      //Listen to action from FlutterCallkitIncoming\n-      FlutterCallkitIncoming.onEvent.listen((CallEvent? event) async {\n-       switch (event!.event) {\n-        case Event.actionCallAccept:\n-         // Set the telnyx metadata for access when the app comes to foreground\n-         TelnyxClient.setPushMetaData(\n-                 message.data, isAnswer: true, isDecline: false);\n-         break;\n-        case Event.actionCallDecline:\n-        /*\n-        * When the user declines the call from the push notification, the app will no longer be visible, and we have to\n-        * handle the endCall user here.\n-        * Login to the TelnyxClient and end the call\n-        * */\n-          ...\n-       }});\n-}\n-\n-\n-```\n-\n-4. Use the `TelnyxClient.getPushMetaData()` method to retrieve the metadata when the app comes to the foreground. This data is only available on 1st access and becomes `null` afterward.\n-```dart\n-    Future<void> _handlePushNotification() async {\n-       final  data = await TelnyxClient.getPushMetaData();\n-       PushMetaData? pushMetaData = PushMetaData.fromJson(data);\n-      if (pushMetaData != null) {\n-        _telnyxClient.handlePushNotification(pushMetaData, credentialConfig, tokenConfig);\n+          }\n+        ...\n       }\n-    }\n-```\n+ }\n \n-5. To Handle push calls on foreground, Listen for Call Events and invoke the `handlePushNotification` method\n-```dart\n-FlutterCallkitIncoming.onEvent.listen((CallEvent? event) {\n-   switch (event!.event) {\n-   case Event.actionCallIncoming:\n-   // retrieve the push metadata from extras\n-   final data = await TelnyxClient.getPushData();\n-   ...\n-  _telnyxClient.handlePushNotification(pushMetaData, credentialConfig, tokenConfig);\n-    break;\n-   case Event.actionCallStart:\n-    ....\n-   break;\n-   case Event.actionCallAccept:\n-     ...\n-   logger.i('Call Accepted Attach Call');\n-   break;\n-   });\n-```\n \n-#### Best Practices for Push Notifications on Android \n-1. Request for Notification Permissions for android 13+ devices to show push notifications. More information can be found [here](https://developer.android.com/develop/ui/views/notifications/notification-permission)\n-2. Push Notifications only work in foreground for apps that are run in `debug` mode (You will not receive push notifications when you terminate the app while running in debug mode).\n-3. On Foreground calls, you can use the `FirebaseMessaging.onMessage.listen` method to listen for incoming calls and show a notification.\n-```dart\n- FirebaseMessaging.onMessage.listen((RemoteMessage message) {\n-        TelnyxClient.setPushMetaData(message.data);\n-        NotificationService.showNotification(message);\n-        mainViewModel.callFromPush = true;\n-      });\n-```\n-4. To handle push notifications on the background,  use the `FirebaseMessaging.onBackgroundMessage` method to listen for incoming calls and show a notification and make sure to set the ` TelnyxClient.setPushMetaData` when user answers the call.\n-```dart \n- TelnyxClient.setPushMetaData(\n-                 message.data, isAnswer: true, isDecline: false);\n-```\n-5. When you call the `telnyxClient.handlePushNotification` it connects to the `telnyxClient`, make sure not to call the `telnyxClient.connect()` method after this. e.g an Edge case might be if you call `telnyxClient.connect()` on Widget `init` method it\n-   will always call the `connect` method\n+  if (_incomingInvite != null) {\n \n+  }\n \n-6. Early Answer/Decline : Users may answer/decline the call too early before a socket connection is established. To handle this situation,\n-assert if the `IncomingInviteParams` is not null and only accept with below logic\n-```dart\n \n-  bool waitingForInvite = false;\n \n-      if (_incomingInvite != null) {\n-\n-\n-\n ```\n \n \n  \n"
                },
                {
                    "date": 1724334988739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,461 @@\n+![Pub Version](https://img.shields.io/pub/v/telnyx_webrtc?color=blue&logo=telnyx)\n+[![Flutter Test](https://github.com/team-telnyx/telnyx-webrtc-flutter/actions/workflows/unit_tests.yml/badge.svg)](https://github.com/team-telnyx/telnyx-webrtc-flutter/actions/workflows/unit_tests.yml)\n+\n+# Telnyx Flutter Voice SDK\n+\n+\n+Enable Telnyx real-time communication services on Flutter applications (Android / iOS / Web) :telephone_receiver: :fire:\n+\n+## Features\n+- [x] Create / Receive calls\n+- [x] Hold calls\n+- [x] Mute calls\n+- [x] Dual Tone Multi Frequency\n+\n+## Usage\n+\n+### SIP Credentials\n+In order to start making and receiving calls using the TelnyxRTC SDK you will need to get SIP Credentials:\n+\n+![Screenshot 2022-07-15 at 13 51 45](https://user-images.githubusercontent.com/9112652/179226614-f0477f38-6131-4cef-9c7a-3366f23a89b6.png)\n+\n+1. Access to https://portal.telnyx.com/\n+2. Sign up for a Telnyx Account.\n+3. Create a Credential Connection to configure how you connect your calls.\n+4. Create an Outbound Voice Profile to configure your outbound call settings and assign it to your Credential Connection.\n+\n+For more information on how to generate SIP credentials check the [Telnyx WebRTC quickstart guide](https://developers.telnyx.com/docs/v2/webrtc/quickstart).\n+\n+### Platform Specific Configuration\n+\n+## Android\n+If you are implementing the SDK into an Android application it is important to remember to add the following permissions to your AndroidManifest in order to allow Audio and Internet permissions:\n+\n+```xml\n+    <uses-permission android:name=\"android.permission.INTERNET\"/>\n+    <uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\n+    <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" />\n+```\n+\n+## iOS\n+on the iOS platform, you need to add the microphone permission to your Info.plist file:\n+\n+```xml\n+    <key>NSMicrophoneUsageDescription</key>\n+    <string>$(PRODUCT_NAME) Microphone Usage!</string>\n+```\n+\n+### Telnyx Client\n+TelnyxClient() is the core class of the SDK, and can be used to connect to our backend socket connection, create calls, check state and disconnect, etc.\n+\n+Once an instance is created, you can call the .connect() method to connect to the socket. An error will appear as a socket response if there is no network available:\n+\n+```dart\n+    TelnyxClient _telnyxClient = TelnyxClient();\n+    _telnyxClient.connect();\n+```\n+\n+### Logging into Telnyx Client\n+To log into the Telnyx WebRTC client, you'll need to authenticate using a Telnyx SIP Connection. Follow our [quickstart guide](https://developers.telnyx.com/docs/v2/webrtc/quickstart) to create **JWTs** (JSON Web Tokens) to authenticate. To log in with a token we use the tokinLogin() method. You can also authenticate directly with the SIP Connection `username` and `password` with the credentialLogin() method:\n+\n+ ```dart\n+    _telnyxClient.tokenLogin(tokenConfig)\n+                     //OR\n+    _telnyxClient.credentialLogin(credentialConfig)             \n+ ```\n+\n+**Note:** **tokenConfig** and **credentialConfig** are simple classes that represent login settings for the client to use. They look like this:\n+\n+ ```dart\n+ /// Creates an instance of CredentialConfig which can be used to log in\n+///\n+/// Uses the [sipUser] and [sipPassword] fields to log in\n+/// [sipCallerIDName] and [sipCallerIDNumber] will be the Name and Number associated\n+/// [notificationToken] is the token used to register the device for notifications if required (FCM or APNS)\n+/// The [autoReconnect] flag decided whether or not to attempt a reconnect (3 attempts) in the case of a login failure with\n+/// legitimate credentials\n+class CredentialConfig {\n+  CredentialConfig(this.sipUser, this.sipPassword, this.sipCallerIDName,\n+      this.sipCallerIDNumber, this.notificationToken, this.autoReconnect);\n+\n+  final String sipUser;\n+  final String sipPassword;\n+  final String sipCallerIDName;\n+  final String sipCallerIDNumber;\n+  final String? notificationToken;\n+  final bool? autoReconnect;\n+}\n+\n+/// Creates an instance of TokenConfig which can be used to log in\n+///\n+/// Uses the [sipToken] field to log in\n+/// [sipCallerIDName] and [sipCallerIDNumber] will be the Name and Number associated\n+/// [notificationToken] is the token used to register the device for notifications if required (FCM or APNS)\n+/// The [autoReconnect] flag decided whether or not to attempt a reconnect (3 attempts) in the case of a login failure with\n+/// a legitimate token\n+class TokenConfig {\n+  TokenConfig(this.sipToken, this.sipCallerIDName, this.sipCallerIDNumber,\n+      this.notificationToken, this.autoReconnect);\n+\n+  final String sipToken;\n+  final String sipCallerIDName;\n+  final String sipCallerIDNumber;\n+  final String? notificationToken;\n+  final bool? autoReconnect;\n+}\n+ ```\n+ \n+###  Adding push notifications - Android platform\n+The Android platform makes use of Firebase Cloud Messaging in order to deliver push notifications. To receive notifications when receiving calls on your Android mobile device you will have to enable Firebase Cloud Messaging within your application.\n+For a detailed tutorial, please visit our official [Push Notification Docs](https://developers.telnyx.com/docs/v2/webrtc/push-notifications?type=Android).\n+The Demo app uses the [FlutterCallkitIncoming](https://pub.dev/packages/flutter_callkit_incoming) plugin to show incoming calls. To show a notification when receiving a call, you can follow the steps below:\n+1. Listen for Background Push Notifications, Implement the `FirebaseMessaging.onBackgroundMessage` method in your `main` method\n+```dart\n+\n+@pragma('vm:entry-point')\n+Future<void> main() async {\n+    WidgetsFlutterBinding.ensureInitialized();\n+\n+    if (defaultTargetPlatform == TargetPlatform.android) {\n+      // Android Only - Push Notifications\n+        await Firebase.initializeApp();\n+        FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);\n+      \n+        await FirebaseMessaging.instance\n+                .setForegroundNotificationPresentationOptions(\n+         alert: true,\n+         badge: true,\n+         sound: true,\n+      );\n+    }\n+      runApp(const MyApp());\n+}\n+```\n+\n+2. Optionally Add the `metadata` to CallKitParams `extra` field\n+```dart\n+\n+    static Future showNotification(RemoteMessage message)  {\n+      CallKitParams callKitParams = CallKitParams(\n+        android:...,\n+          ios:...,\n+          extra: message.data,\n+      )\n+      await FlutterCallkitIncoming.showCallkitIncoming(callKitParams);\n+    }\n+```\n+\n+\n+3. Handle the push notification in the `_firebaseMessagingBackgroundHandler` method\n+```dart\n+\n+Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {\n+      //show notifcation\n+      showNotification(message);\n+      \n+      //Listen to action from FlutterCallkitIncoming\n+      FlutterCallkitIncoming.onEvent.listen((CallEvent? event) async {\n+       switch (event!.event) {\n+        case Event.actionCallAccept:\n+         // Set the telnyx metadata for access when the app comes to foreground\n+         TelnyxClient.setPushMetaData(\n+                 message.data, isAnswer: true, isDecline: false);\n+         break;\n+        case Event.actionCallDecline:\n+        /*\n+        * When the user declines the call from the push notification, the app will no longer be visible, and we have to\n+        * handle the endCall user here.\n+        * Login to the TelnyxClient and end the call\n+        * */\n+          ...\n+       }});\n+}\n+\n+\n+```\n+\n+4. Use the `TelnyxClient.getPushMetaData()` method to retrieve the metadata when the app comes to the foreground. This data is only available on 1st access and becomes `null` afterward.\n+```dart\n+    Future<void> _handlePushNotification() async {\n+       final  data = await TelnyxClient.getPushMetaData();\n+       PushMetaData? pushMetaData = PushMetaData.fromJson(data);\n+      if (pushMetaData != null) {\n+        _telnyxClient.handlePushNotification(pushMetaData, credentialConfig, tokenConfig);\n+      }\n+    }\n+```\n+\n+5. To Handle push calls on foreground, Listen for Call Events and invoke the `handlePushNotification` method\n+```dart\n+FlutterCallkitIncoming.onEvent.listen((CallEvent? event) {\n+   switch (event!.event) {\n+   case Event.actionCallIncoming:\n+   // retrieve the push metadata from extras\n+   final data = await TelnyxClient.getPushData();\n+   ...\n+  _telnyxClient.handlePushNotification(pushMetaData, credentialConfig, tokenConfig);\n+    break;\n+   case Event.actionCallStart:\n+    ....\n+   break;\n+   case Event.actionCallAccept:\n+     ...\n+   logger.i('Call Accepted Attach Call');\n+   break;\n+   });\n+```\n+\n+#### Best Practices for Push Notifications on Android \n+1. Request for Notification Permissions for android 13+ devices to show push notifications. More information can be found [here](https://developer.android.com/develop/ui/views/notifications/notification-permission)\n+2. Push Notifications only work in foreground for apps that are run in `debug` mode (You will not receive push notifications when you terminate the app while running in debug mode).\n+3. On Foreground calls, you can use the `FirebaseMessaging.onMessage.listen` method to listen for incoming calls and show a notification.\n+```dart\n+ FirebaseMessaging.onMessage.listen((RemoteMessage message) {\n+        TelnyxClient.setPushMetaData(message.data);\n+        NotificationService.showNotification(message);\n+        mainViewModel.callFromPush = true;\n+      });\n+```\n+4. To handle push notifications on the background,  use the `FirebaseMessaging.onBackgroundMessage` method to listen for incoming calls and show a notification and make sure to set the ` TelnyxClient.setPushMetaData` when user answers the call.\n+```dart \n+ TelnyxClient.setPushMetaData(\n+                 message.data, isAnswer: true, isDecline: false);\n+```\n+5. When you call the `telnyxClient.handlePushNotification` it connects to the `telnyxClient`, make sure not to call the `telnyxClient.connect()` method after this. e.g an Edge case might be if you call `telnyxClient.connect()` on Widget `init` method it\n+   will always call the `connect` method\n+\n+\n+6. Early Answer/Decline : Users may answer/decline the call too early before a socket connection is established. To handle this situation,\n+assert if the `IncomingInviteParams` is not null and only accept/decline if this is availalble. \n+```dart\n+bool waitingForInvite = false;\n+\n+void accept() {\n+\n+if (_incomingInvite != null) {\n+  // accept the call if the incomingInvite arrives on time \n+      _currentCall = _telnyxClient.acceptCall(\n+          _incomingInvite!, _localName, _localNumber, \"State\");\n+    } else {\n+      // set waitingForInvite to true if we have an early accept\n+      waitingForInvite = true;\n+    }\n+}\n+\n+\n+ _telnyxClient.onSocketMessageReceived = (TelnyxMessage message) {\n+      switch (message.socketMethod) {\n+        ...\n+        case SocketMethod.INVITE:\n+          {\n+            if (callFromPush) {\n+              // For early accept of call\n+              if (waitingForInvite) {\n+                //accept the call\n+                accept();\n+                waitingForInvite = false;\n+              }\n+              callFromPush = false;\n+            }\n+\n+          }\n+        ...\n+      }\n+ }\n+```\n+\n+\n+ \n+### Adding push notifications - iOS platform\n+The iOS Platform makes use of the Apple Push Notification Service (APNS) and Pushkit in order to deliver and receive push notifications\n+For a detailed tutorial, please visit our official [Push Notification Docs](https://developers.telnyx.com/docs/v2/webrtc/push-notifications?lang=ios)\n+1. Register/Invalidate the push device token for iOS\n+```swift\n+        func pushRegistry(_ registry: PKPushRegistry, didUpdate credentials: PKPushCredentials, for type: PKPushType) {\n+            print(credentials.token)\n+            let deviceToken = credentials.token.map { String(format: \"%02x\", $0) }.joined()\n+            //Save deviceToken to your server\n+            SwiftFlutterCallkitIncomingPlugin.sharedInstance?.setDevicePushTokenVoIP(deviceToken)\n+        }\n+        \n+        func pushRegistry(_ registry: PKPushRegistry, didInvalidatePushTokenFor type: PKPushType) {\n+            SwiftFlutterCallkitIncomingPlugin.sharedInstance?.setDevicePushTokenVoIP(\"\")\n+        }\n+```\n+\n+2. For foreground calls to work, you need to register with callkit on the restorationHandler delegate function. You can also choose to register with callkit using iOS official documentation on\n+   [CallKit](https://developer.apple.com/documentation/callkit/).\n+```swift\n+  override func application(_ application: UIApplication,\n+                                  continue userActivity: NSUserActivity,\n+                                  restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {\n+                                  \n+            let nameCaller = handleObj.getDecryptHandle()[\"nameCaller\"] as? String ?? \"\"\n+            let handle = handleObj.getDecryptHandle()[\"handle\"] as? String ?? \"\"\n+            let data = flutter_callkit_incoming.Data(id: UUID().uuidString, nameCaller: nameCaller, handle: handle, type: isVideo ? 1 : 0)\n+            //set more data...\n+            data.nameCaller = \"dummy\"\n+            SwiftFlutterCallkitIncomingPlugin.sharedInstance?.startCall(data, fromPushKit: true)\n+         \n+         }                         \n+```\n+3. Listen for incoming calls in AppDelegate.swift class\n+```swift \n+    func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -> Void) {\n+            print(\"didReceiveIncomingPushWith\")\n+            guard type == .voIP else { return }\n+            \n+            if let metadata = payload.dictionaryPayload[\"metadata\"] as? [String: Any] {\n+                var callID = UUID.init().uuidString\n+                if let newCallId = (metadata[\"call_id\"] as? String),\n+                   !newCallId.isEmpty {\n+                    callID = newCallId\n+                }\n+                let callerName = (metadata[\"caller_name\"] as? String) ?? \"\"\n+                let callerNumber = (metadata[\"caller_number\"] as? String) ?? \"\"\n+                \n+                let id = payload.dictionaryPayload[\"call_id\"] as? String ??  UUID().uuidString\n+                \n+                let data = flutter_callkit_incoming.Data(id: id, nameCaller: callerName, handle: callerNumber, type: isVideo ? 1 : 0)\n+                data.extra = payload.dictionaryPayload as NSDictionary\n+                data.normalHandle = 1              \n+                \n+                let caller = callerName.isEmpty ? (callerNumber.isEmpty ? \"Unknown\" : callerNumber) : callerName\n+                let uuid = UUID(uuidString: callID)\n+                \n+                data.uuid = uuid!.uuidString\n+                data.nameCaller = caller\n+                \n+                SwiftFlutterCallkitIncomingPlugin.sharedInstance?.showCallkitIncoming(data, fromPushKit: true)\n+            }\n+        }\n+```\n+\n+4. Listen for Call Events and invoke the `handlePushNotification` method\n+```dart\n+   FlutterCallkitIncoming.onEvent.listen((CallEvent? event) {\n+   switch (event!.event) {\n+   case Event.actionCallIncoming:\n+   // retrieve the push metadata from extras\n+    PushMetaData? pushMetaData = PushMetaData.fromJson(event.body['extra']['metadata']);\n+    _telnyxClient.handlePushNotification(pushMetaData, credentialConfig, tokenConfig);\n+    break;\n+   case Event.actionCallStart:\n+    ....\n+   break;\n+   case Event.actionCallAccept:\n+     ...\n+   logger.i('Call Accepted Attach Call');\n+   break;\n+   });\n+```\n+\n+\n+\n+#### Best Practices for Push Notifications on iOS\n+1. Push Notifications only work in foreground for apps that are run in `debug` mode (You will not receive push notifications when you terminate the app while running in debug mode). Make sure you are in `release` mode. Preferably test using Testfight or Appstore.\n+To test if push notifications are working, disconnect the telnyx client (while app is in foreground) and make a call to the device. You should receive a push notification.\n+\n+\n+### Creating a call invitation\n+In order to make a call invitation, we first create an instance of the Call class with the .call instance. This creates a Call class which can be used to interact with calls (invite, accept, decline, etc).\n+To then send an invite, we can use the .newInvite() method which requires you to provide your callerName, callerNumber, the destinationNumber (or SIP credential), and your clientState (any String value).\n+\n+```dart\n+    _telnyxClient\n+        .call\n+        .newInvite(\"callerName\", \"000000000\", destination, \"State\");\n+```\n+\n+### Accepting a call\n+In order to be able to accept a call, we first need to listen for invitations. We do this by getting the Telnyx Socket Response callbacks:\n+\n+```dart\n+ // Observe Socket Messages Received\n+_telnyxClient.onSocketMessageReceived = (TelnyxMessage message) {\n+  switch (message.socketMethod) {\n+        case SocketMethod.CLIENT_READY:\n+        {\n+           // Fires once client has correctly been setup and logged into, you can now make calls. \n+           break;\n+        }\n+        case SocketMethod.LOGIN:\n+        {\n+            // Handle a successful login - Update UI or Navigate to new screen, etc. \n+            break;\n+        }\n+        case SocketMethod.INVITE:\n+        {\n+            // Handle an invitation Update UI or Navigate to new screen, etc. \n+            // Then, through an answer button of some kind we can accept the call with:\n+            _incomingInvite = message.message.inviteParams;\n+            _telnyxClient.createCall().acceptCall(\n+                _incomingInvite, \"callerName\", \"000000000\", \"State\");\n+            break;\n+        }\n+        case SocketMethod.ANSWER:\n+        {\n+           // Handle a received call answer - Update UI or Navigate to new screen, etc.\n+          break;\n+        }\n+        case SocketMethod.BYE:\n+        {\n+           // Handle a call rejection or ending - Update UI or Navigate to new screen, etc.\n+           break;\n+      }\n+    }\n+    notifyListeners();\n+};\n+```\n+\n+We can then use this method to create a listener that listens for an invitation and, in this case, answers it straight away. A real implementation would be more suited to show some UI and allow manual accept / decline operations. \n+\n+### Decline / End Call\n+\n+In order to end a call, we can get a stored instance of Call and call the .endCall(callID) method. To decline an incoming call we first create the call with the .createCall() method and then call the .endCall(callID) method:\n+\n+```dart\n+    if (_ongoingCall) {\n+      _telnyxClient.call.endCall(_telnyxClient.call.callId);\n+    } else {\n+      _telnyxClient.createCall().endCall(_incomingInvite?.callID);\n+    }\n+```\n+\n+### DTMF (Dual Tone Multi Frequency)\n+\n+In order to send a DTMF message while on a call you can call the .dtmf(callID, tone), method where tone is a String value of the character you would like pressed:\n+\n+```dart\n+    _telnyxClient.call.dtmf(_telnyxClient.call.callId, tone);\n+```\n+\n+### Mute a call\n+\n+To mute a call, you can simply call the .onMuteUnmutePressed() method:\n+\n+```dart\n+    _telnyxClient.call.onMuteUnmutePressed();\n+```\n+\n+### Toggle loud speaker\n+\n+To toggle loud speaker, you can simply call .enableSpeakerPhone(bool):\n+\n+```dart\n+    _telnyxClient.call.enableSpeakerPhone(true);\n+```\n+\n+### Put a call on hold\n+\n+To put a call on hold, you can simply call the .onHoldUnholdPressed() method:\n+\n+```dart\n+    _telnyxClient.call.onHoldUnholdPressed();\n+```\n+\n+Questions? Comments? Building something rad? [Join our Slack channel](https://joinslack.telnyx.com/) and share.\n+\n+## License\n+\n+[`MIT Licence`](./LICENSE) © [Telnyx](https://github.com/team-telnyx)\n"
                }
            ],
            "date": 1724322403635,
            "name": "Commit-0",
            "content": "![Pub Version](https://img.shields.io/pub/v/telnyx_webrtc?color=blue&logo=telnyx)\n[![Flutter Test](https://github.com/team-telnyx/telnyx-webrtc-flutter/actions/workflows/unit_tests.yml/badge.svg)](https://github.com/team-telnyx/telnyx-webrtc-flutter/actions/workflows/unit_tests.yml)\n\n# Telnyx Flutter Voice SDK\n\n\nEnable Telnyx real-time communication services on Flutter applications (Android / iOS / Web) :telephone_receiver: :fire:\n\n## Features\n- [x] Create / Receive calls\n- [x] Hold calls\n- [x] Mute calls\n- [x] Dual Tone Multi Frequency\n\n## Usage\n\n### SIP Credentials\nIn order to start making and receiving calls using the TelnyxRTC SDK you will need to get SIP Credentials:\n\n![Screenshot 2022-07-15 at 13 51 45](https://user-images.githubusercontent.com/9112652/179226614-f0477f38-6131-4cef-9c7a-3366f23a89b6.png)\n\n1. Access to https://portal.telnyx.com/\n2. Sign up for a Telnyx Account.\n3. Create a Credential Connection to configure how you connect your calls.\n4. Create an Outbound Voice Profile to configure your outbound call settings and assign it to your Credential Connection.\n\nFor more information on how to generate SIP credentials check the [Telnyx WebRTC quickstart guide](https://developers.telnyx.com/docs/v2/webrtc/quickstart).\n\n### Platform Specific Configuration\n\n## Android\nIf you are implementing the SDK into an Android application it is important to remember to add the following permissions to your AndroidManifest in order to allow Audio and Internet permissions:\n\n```xml\n    <uses-permission android:name=\"android.permission.INTERNET\"/>\n    <uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\n    <uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" />\n```\n\n## iOS\non the iOS platform, you need to add the microphone permission to your Info.plist file:\n\n```xml\n    <key>NSMicrophoneUsageDescription</key>\n    <string>$(PRODUCT_NAME) Microphone Usage!</string>\n```\n\n### Telnyx Client\nTelnyxClient() is the core class of the SDK, and can be used to connect to our backend socket connection, create calls, check state and disconnect, etc.\n\nOnce an instance is created, you can call the .connect() method to connect to the socket. An error will appear as a socket response if there is no network available:\n\n```dart\n    TelnyxClient _telnyxClient = TelnyxClient();\n    _telnyxClient.connect();\n```\n\n### Logging into Telnyx Client\nTo log into the Telnyx WebRTC client, you'll need to authenticate using a Telnyx SIP Connection. Follow our [quickstart guide](https://developers.telnyx.com/docs/v2/webrtc/quickstart) to create **JWTs** (JSON Web Tokens) to authenticate. To log in with a token we use the tokinLogin() method. You can also authenticate directly with the SIP Connection `username` and `password` with the credentialLogin() method:\n\n ```dart\n    _telnyxClient.tokenLogin(tokenConfig)\n                     //OR\n    _telnyxClient.credentialLogin(credentialConfig)             \n ```\n\n**Note:** **tokenConfig** and **credentialConfig** are simple classes that represent login settings for the client to use. They look like this:\n\n ```dart\n /// Creates an instance of CredentialConfig which can be used to log in\n///\n/// Uses the [sipUser] and [sipPassword] fields to log in\n/// [sipCallerIDName] and [sipCallerIDNumber] will be the Name and Number associated\n/// [notificationToken] is the token used to register the device for notifications if required (FCM or APNS)\n/// The [autoReconnect] flag decided whether or not to attempt a reconnect (3 attempts) in the case of a login failure with\n/// legitimate credentials\nclass CredentialConfig {\n  CredentialConfig(this.sipUser, this.sipPassword, this.sipCallerIDName,\n      this.sipCallerIDNumber, this.notificationToken, this.autoReconnect);\n\n  final String sipUser;\n  final String sipPassword;\n  final String sipCallerIDName;\n  final String sipCallerIDNumber;\n  final String? notificationToken;\n  final bool? autoReconnect;\n}\n\n/// Creates an instance of TokenConfig which can be used to log in\n///\n/// Uses the [sipToken] field to log in\n/// [sipCallerIDName] and [sipCallerIDNumber] will be the Name and Number associated\n/// [notificationToken] is the token used to register the device for notifications if required (FCM or APNS)\n/// The [autoReconnect] flag decided whether or not to attempt a reconnect (3 attempts) in the case of a login failure with\n/// a legitimate token\nclass TokenConfig {\n  TokenConfig(this.sipToken, this.sipCallerIDName, this.sipCallerIDNumber,\n      this.notificationToken, this.autoReconnect);\n\n  final String sipToken;\n  final String sipCallerIDName;\n  final String sipCallerIDNumber;\n  final String? notificationToken;\n  final bool? autoReconnect;\n}\n ```\n \n###  Adding push notifications - Android platform\nThe Android platform makes use of Firebase Cloud Messaging in order to deliver push notifications. To receive notifications when receiving calls on your Android mobile device you will have to enable Firebase Cloud Messaging within your application.\nFor a detailed tutorial, please visit our official [Push Notification Docs](https://developers.telnyx.com/docs/v2/webrtc/push-notifications?type=Android).\nThe Demo app uses the [FlutterCallkitIncoming](https://pub.dev/packages/flutter_callkit_incoming) plugin to show incoming calls. To show a notification when receiving a call, you can follow the steps below:\n1. Listen for Background Push Notifications, Implement the `FirebaseMessaging.onBackgroundMessage` method in your `main` method\n```dart\n\n@pragma('vm:entry-point')\nFuture<void> main() async {\n    WidgetsFlutterBinding.ensureInitialized();\n\n    if (defaultTargetPlatform == TargetPlatform.android) {\n      // Android Only - Push Notifications\n        await Firebase.initializeApp();\n        FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);\n      \n        await FirebaseMessaging.instance\n                .setForegroundNotificationPresentationOptions(\n         alert: true,\n         badge: true,\n         sound: true,\n      );\n    }\n      runApp(const MyApp());\n}\n```\n\n2. Optionally Add the `metadata` to CallKitParams `extra` field\n```dart\n\n    static Future showNotification(RemoteMessage message)  {\n      CallKitParams callKitParams = CallKitParams(\n        android:...,\n          ios:...,\n          extra: message.data,\n      )\n      await FlutterCallkitIncoming.showCallkitIncoming(callKitParams);\n    }\n```\n\n\n3. Handle the push notification in the `_firebaseMessagingBackgroundHandler` method\n```dart\n\nFuture<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {\n      //show notifcation\n      showNotification(message);\n      \n      //Listen to action from FlutterCallkitIncoming\n      FlutterCallkitIncoming.onEvent.listen((CallEvent? event) async {\n       switch (event!.event) {\n        case Event.actionCallAccept:\n         // Set the telnyx metadata for access when the app comes to foreground\n         TelnyxClient.setPushMetaData(\n                 message.data, isAnswer: true, isDecline: false);\n         break;\n        case Event.actionCallDecline:\n        /*\n        * When the user declines the call from the push notification, the app will no longer be visible, and we have to\n        * handle the endCall user here.\n        * Login to the TelnyxClient and end the call\n        * */\n          ...\n       }});\n}\n\n\n```\n\n4. Use the `TelnyxClient.getPushMetaData()` method to retrieve the metadata when the app comes to the foreground. This data is only available on 1st access and becomes `null` afterward.\n```dart\n    Future<void> _handlePushNotification() async {\n       final  data = await TelnyxClient.getPushMetaData();\n       PushMetaData? pushMetaData = PushMetaData.fromJson(data);\n      if (pushMetaData != null) {\n        _telnyxClient.handlePushNotification(pushMetaData, credentialConfig, tokenConfig);\n      }\n    }\n```\n\n5. To Handle push calls on foreground, Listen for Call Events and invoke the `handlePushNotification` method\n```dart\nFlutterCallkitIncoming.onEvent.listen((CallEvent? event) {\n   switch (event!.event) {\n   case Event.actionCallIncoming:\n   // retrieve the push metadata from extras\n   final data = await TelnyxClient.getPushData();\n   ...\n  _telnyxClient.handlePushNotification(pushMetaData, credentialConfig, tokenConfig);\n    break;\n   case Event.actionCallStart:\n    ....\n   break;\n   case Event.actionCallAccept:\n     ...\n   logger.i('Call Accepted Attach Call');\n   break;\n   });\n```\n\n#### Best Practices for Push Notifications on Android \n1. Request for Notification Permissions for android 13+ devices to show push notifications. More information can be found [here](https://developer.android.com/develop/ui/views/notifications/notification-permission)\n2. Push Notifications only work in foreground for apps that are run in `debug` mode (You will not receive push notifications when you terminate the app while running in debug mode).\n3. On Foreground calls, you can use the `FirebaseMessaging.onMessage.listen` method to listen for incoming calls and show a notification.\n```dart\n FirebaseMessaging.onMessage.listen((RemoteMessage message) {\n        TelnyxClient.setPushMetaData(message.data);\n        NotificationService.showNotification(message);\n        mainViewModel.callFromPush = true;\n      });\n```\n4. To handle push notifications on the background,  use the `FirebaseMessaging.onBackgroundMessage` method to listen for incoming calls and show a notification and make sure to set the ` TelnyxClient.setPushMetaData` when user answers the call.\n```dart \n TelnyxClient.setPushMetaData(\n                 message.data, isAnswer: true, isDecline: false);\n```\n5. When you call the `telnyxClient.handlePushNotification` it connects to the `telnyxClient`, make sure not to call the `telnyxClient.connect()` method after this. e.g an Edge case might be if you call `telnyxClient.connect()` on Widget `init` method it\n   will always call the `connect` method\n\n\n6. Early Answer/Decline : Users may answer/decline the call too early before a socket connection is established. To handle this situation,\nassert if the `IncomingInviteParams` is not null and only accept with below logic\n```dart\n\n  bool waitingForInvite = false;\n\n      if (_incomingInvite != null) {\n\n\n\n```\n\n\n \n### Adding push notifications - iOS platform\nThe iOS Platform makes use of the Apple Push Notification Service (APNS) and Pushkit in order to deliver and receive push notifications\nFor a detailed tutorial, please visit our official [Push Notification Docs](https://developers.telnyx.com/docs/v2/webrtc/push-notifications?lang=ios)\n1. Register/Invalidate the push device token for iOS\n```swift\n        func pushRegistry(_ registry: PKPushRegistry, didUpdate credentials: PKPushCredentials, for type: PKPushType) {\n            print(credentials.token)\n            let deviceToken = credentials.token.map { String(format: \"%02x\", $0) }.joined()\n            //Save deviceToken to your server\n            SwiftFlutterCallkitIncomingPlugin.sharedInstance?.setDevicePushTokenVoIP(deviceToken)\n        }\n        \n        func pushRegistry(_ registry: PKPushRegistry, didInvalidatePushTokenFor type: PKPushType) {\n            SwiftFlutterCallkitIncomingPlugin.sharedInstance?.setDevicePushTokenVoIP(\"\")\n        }\n```\n\n2. For foreground calls to work, you need to register with callkit on the restorationHandler delegate function. You can also choose to register with callkit using iOS official documentation on\n   [CallKit](https://developer.apple.com/documentation/callkit/).\n```swift\n  override func application(_ application: UIApplication,\n                                  continue userActivity: NSUserActivity,\n                                  restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {\n                                  \n            let nameCaller = handleObj.getDecryptHandle()[\"nameCaller\"] as? String ?? \"\"\n            let handle = handleObj.getDecryptHandle()[\"handle\"] as? String ?? \"\"\n            let data = flutter_callkit_incoming.Data(id: UUID().uuidString, nameCaller: nameCaller, handle: handle, type: isVideo ? 1 : 0)\n            //set more data...\n            data.nameCaller = \"dummy\"\n            SwiftFlutterCallkitIncomingPlugin.sharedInstance?.startCall(data, fromPushKit: true)\n         \n         }                         \n```\n3. Listen for incoming calls in AppDelegate.swift class\n```swift \n    func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -> Void) {\n            print(\"didReceiveIncomingPushWith\")\n            guard type == .voIP else { return }\n            \n            if let metadata = payload.dictionaryPayload[\"metadata\"] as? [String: Any] {\n                var callID = UUID.init().uuidString\n                if let newCallId = (metadata[\"call_id\"] as? String),\n                   !newCallId.isEmpty {\n                    callID = newCallId\n                }\n                let callerName = (metadata[\"caller_name\"] as? String) ?? \"\"\n                let callerNumber = (metadata[\"caller_number\"] as? String) ?? \"\"\n                \n                let id = payload.dictionaryPayload[\"call_id\"] as? String ??  UUID().uuidString\n                \n                let data = flutter_callkit_incoming.Data(id: id, nameCaller: callerName, handle: callerNumber, type: isVideo ? 1 : 0)\n                data.extra = payload.dictionaryPayload as NSDictionary\n                data.normalHandle = 1              \n                \n                let caller = callerName.isEmpty ? (callerNumber.isEmpty ? \"Unknown\" : callerNumber) : callerName\n                let uuid = UUID(uuidString: callID)\n                \n                data.uuid = uuid!.uuidString\n                data.nameCaller = caller\n                \n                SwiftFlutterCallkitIncomingPlugin.sharedInstance?.showCallkitIncoming(data, fromPushKit: true)\n            }\n        }\n```\n\n4. Listen for Call Events and invoke the `handlePushNotification` method\n```dart\n   FlutterCallkitIncoming.onEvent.listen((CallEvent? event) {\n   switch (event!.event) {\n   case Event.actionCallIncoming:\n   // retrieve the push metadata from extras\n    PushMetaData? pushMetaData = PushMetaData.fromJson(event.body['extra']['metadata']);\n    _telnyxClient.handlePushNotification(pushMetaData, credentialConfig, tokenConfig);\n    break;\n   case Event.actionCallStart:\n    ....\n   break;\n   case Event.actionCallAccept:\n     ...\n   logger.i('Call Accepted Attach Call');\n   break;\n   });\n```\n\n\n\n#### Best Practices for Push Notifications on iOS\n1. Push Notifications only work in foreground for apps that are run in `debug` mode (You will not receive push notifications when you terminate the app while running in debug mode). Make sure you are in `release` mode. Preferably test using Testfight or Appstore.\nTo test if push notifications are working, disconnect the telnyx client (while app is in foreground) and make a call to the device. You should receive a push notification.\n\n\n### Creating a call invitation\nIn order to make a call invitation, we first create an instance of the Call class with the .call instance. This creates a Call class which can be used to interact with calls (invite, accept, decline, etc).\nTo then send an invite, we can use the .newInvite() method which requires you to provide your callerName, callerNumber, the destinationNumber (or SIP credential), and your clientState (any String value).\n\n```dart\n    _telnyxClient\n        .call\n        .newInvite(\"callerName\", \"000000000\", destination, \"State\");\n```\n\n### Accepting a call\nIn order to be able to accept a call, we first need to listen for invitations. We do this by getting the Telnyx Socket Response callbacks:\n\n```dart\n // Observe Socket Messages Received\n_telnyxClient.onSocketMessageReceived = (TelnyxMessage message) {\n  switch (message.socketMethod) {\n        case SocketMethod.CLIENT_READY:\n        {\n           // Fires once client has correctly been setup and logged into, you can now make calls. \n           break;\n        }\n        case SocketMethod.LOGIN:\n        {\n            // Handle a successful login - Update UI or Navigate to new screen, etc. \n            break;\n        }\n        case SocketMethod.INVITE:\n        {\n            // Handle an invitation Update UI or Navigate to new screen, etc. \n            // Then, through an answer button of some kind we can accept the call with:\n            _incomingInvite = message.message.inviteParams;\n            _telnyxClient.createCall().acceptCall(\n                _incomingInvite, \"callerName\", \"000000000\", \"State\");\n            break;\n        }\n        case SocketMethod.ANSWER:\n        {\n           // Handle a received call answer - Update UI or Navigate to new screen, etc.\n          break;\n        }\n        case SocketMethod.BYE:\n        {\n           // Handle a call rejection or ending - Update UI or Navigate to new screen, etc.\n           break;\n      }\n    }\n    notifyListeners();\n};\n```\n\nWe can then use this method to create a listener that listens for an invitation and, in this case, answers it straight away. A real implementation would be more suited to show some UI and allow manual accept / decline operations. \n\n### Decline / End Call\n\nIn order to end a call, we can get a stored instance of Call and call the .endCall(callID) method. To decline an incoming call we first create the call with the .createCall() method and then call the .endCall(callID) method:\n\n```dart\n    if (_ongoingCall) {\n      _telnyxClient.call.endCall(_telnyxClient.call.callId);\n    } else {\n      _telnyxClient.createCall().endCall(_incomingInvite?.callID);\n    }\n```\n\n### DTMF (Dual Tone Multi Frequency)\n\nIn order to send a DTMF message while on a call you can call the .dtmf(callID, tone), method where tone is a String value of the character you would like pressed:\n\n```dart\n    _telnyxClient.call.dtmf(_telnyxClient.call.callId, tone);\n```\n\n### Mute a call\n\nTo mute a call, you can simply call the .onMuteUnmutePressed() method:\n\n```dart\n    _telnyxClient.call.onMuteUnmutePressed();\n```\n\n### Toggle loud speaker\n\nTo toggle loud speaker, you can simply call .enableSpeakerPhone(bool):\n\n```dart\n    _telnyxClient.call.enableSpeakerPhone(true);\n```\n\n### Put a call on hold\n\nTo put a call on hold, you can simply call the .onHoldUnholdPressed() method:\n\n```dart\n    _telnyxClient.call.onHoldUnholdPressed();\n```\n\nQuestions? Comments? Building something rad? [Join our Slack channel](https://joinslack.telnyx.com/) and share.\n\n## License\n\n[`MIT Licence`](./LICENSE) © [Telnyx](https://github.com/team-telnyx)\n"
        }
    ]
}