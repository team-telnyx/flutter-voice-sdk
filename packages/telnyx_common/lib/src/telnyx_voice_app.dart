import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:telnyx_webrtc/telnyx_client.dart';
import 'package:telnyx_common/src/telnyx_voip_client.dart';
import 'package:telnyx_common/src/models/connection_state.dart' as telnyx_state;
import 'package:telnyx_common/telnyx_common.dart' as telnyx;
import 'package:telnyx_common/src/utils/background_detector.dart';

/// A comprehensive wrapper widget that handles all Telnyx SDK lifecycle management.
///
/// This widget automatically handles:
/// - Push notification initialization from terminated state
/// - Background/foreground lifecycle detection and auto-reconnection
/// - Login state management with automatic reconnection
/// - CallKit integration preparation
///
/// Simply wrap your main app widget with this to get full Telnyx functionality:
/// ```dart
/// TelnyxVoiceApp(
///   voipClient: myVoipClient,
///   child: MyApp(),
/// )
/// ```
class TelnyxVoiceApp extends StatefulWidget {
  /// The TelnyxVoipClient instance to manage
  final TelnyxVoipClient voipClient;

  /// The child widget (typically your main app)
  final Widget child;

  /// Optional callback when push notification processing starts
  final VoidCallback? onPushNotificationProcessingStarted;

  /// Optional callback when push notification processing completes
  final VoidCallback? onPushNotificationProcessingCompleted;

  /// Optional callback for additional background/foreground handling
  final void Function(AppLifecycleState state)? onAppLifecycleStateChanged;

  /// Whether to enable automatic login/reconnection (default: true)
  final bool enableAutoReconnect;

  /// Whether to skip web platform for background detection (default: true)
  final bool skipWebBackgroundDetection;

  const TelnyxVoiceApp({
    super.key,
    required this.voipClient,
    required this.child,
    this.onPushNotificationProcessingStarted,
    this.onPushNotificationProcessingCompleted,
    this.onAppLifecycleStateChanged,
    this.enableAutoReconnect = true,
    this.skipWebBackgroundDetection = true,
  });

  @override
  State<TelnyxVoiceApp> createState() => _TelnyxVoiceAppState();

  /// Static factory method that handles all common SDK initialization boilerplate.
  ///
  /// This is the recommended way to initialize the Telnyx Voice SDK in your app.
  /// It ensures that Firebase, background handlers, and other dependencies are
  /// set up correctly before the app runs.
  ///
  /// This method:
  /// - Initializes Firebase using the provided or auto-detected options.
  /// - Registers the background push notification handler.
  /// - Returns a fully configured `TelnyxVoiceApp` widget to be used in `runApp()`.
  ///
  /// ## Usage:
  /// ```dart
  /// void main() async {
  ///   runApp(await TelnyxVoiceApp.initializeAndCreate(
  ///     voipClient: myVoipClient,
  ///     backgroundHandler: _backgroundHandler,
  ///     child: MyApp(),
  ///   ));
  /// }
  /// ```
  static Future<Widget> initializeAndCreate({
    /// The `TelnyxVoipClient` instance that will be managed by this widget.
    required TelnyxVoipClient voipClient,

    /// The main widget of your application (e.g., `MyApp`).
    required Widget child,

    /// The top-level function that will handle background push notifications.
    /// This function must be annotated with `@pragma('vm:entry-point')`.
    /// If not provided, background push notifications will not be handled when the
    /// app is terminated.
    Future<void> Function(RemoteMessage)? backgroundMessageHandler,

    /// Optional Firebase options for initialization.
    /// If not provided, the SDK will attempt to use the default Firebase options
    /// generated by the FlutterFire CLI (`firebase_options.dart`).
    FirebaseOptions? firebaseOptions,

    /// Optional callback that is triggered when the SDK begins processing an
    /// initial push notification upon app launch. You could show a loading state here for example.
    VoidCallback? onPushNotificationProcessingStarted,

    /// Optional callback that is triggered when the SDK completes processing an
    /// initial push notification upon app launch. We recommend using this to start listening to
    /// state changes in your app.
    VoidCallback? onPushNotificationProcessingCompleted,

    /// Optional callback for listening to app lifecycle state changes.
    /// This allows for custom logic when the app enters the foreground, background, etc.
    void Function(AppLifecycleState state)? onAppLifecycleStateChanged,

    /// Determines whether the SDK should automatically handle reconnections
    /// when the app comes to the foreground. Defaults to `true`.
    bool enableAutoReconnect = true,

    /// Determines whether to skip background detection on web platforms.
    /// Defaults to `true`.
    bool skipWebBackgroundDetection = true,
  }) async {
    // Initialize Firebase with auto-detection
    await _initializeFirebase(firebaseOptions);

    // Register background message handler if provided
    if (backgroundMessageHandler != null) {
      FirebaseMessaging.onBackgroundMessage(backgroundMessageHandler);
    }

    if (kDebugMode) {
      debugPrint('[TelnyxVoiceApp] SDK initialization complete');
    }

    return TelnyxVoiceApp(
      voipClient: voipClient,
      child: child,
      onPushNotificationProcessingStarted: onPushNotificationProcessingStarted,
      onPushNotificationProcessingCompleted:
          onPushNotificationProcessingCompleted,
      onAppLifecycleStateChanged: onAppLifecycleStateChanged,
      enableAutoReconnect: enableAutoReconnect,
      skipWebBackgroundDetection: skipWebBackgroundDetection,
    );
  }

  /// Handles background push notifications in the background isolate.
  static Future<void> handleBackgroundPush(RemoteMessage message) async {
    if (kDebugMode) {
      debugPrint('[TelnyxVoiceApp] Background push received: ${message.data}');
    }

    try {
      await _initializeFirebaseInIsolate();
      TelnyxClient.setPushMetaData(message.data,
          isAnswer: false, isDecline: false);

      final backgroundClient = await _createBackgroundClient();
      await backgroundClient.handlePushNotification(message.data);

      if (kDebugMode) {
        debugPrint('[TelnyxVoiceApp] Background push processed successfully');
      }
    } catch (e) {
      if (kDebugMode) {
        debugPrint('[TelnyxVoiceApp] Error processing background push: $e');
      }
    }
  }

  /// Initializes Firebase with automatic options detection.
  static Future<void> _initializeFirebase(FirebaseOptions? options) async {
    try {
      await Firebase.initializeApp(options: options);
      if (kDebugMode) {
        debugPrint('[TelnyxVoiceApp] Firebase initialized successfully');
      }
    } catch (e) {
      if (kDebugMode) {
        debugPrint('[TelnyxVoiceApp] Firebase initialization failed: $e');
      }
    }
  }

  /// Initializes Firebase in the background isolate.
  static Future<void> _initializeFirebaseInIsolate() async {
    try {
      await Firebase.initializeApp();
      if (kDebugMode) {
        debugPrint('[TelnyxVoiceApp] Firebase initialized in background isolate');
      }
    } catch (e) {
      if (kDebugMode) {
        debugPrint('[TelnyxVoiceApp] Firebase background initialization failed: $e');
      }
    }
  }

  /// Creates a TelnyxVoipClient instance for background push processing.
  static Future<TelnyxVoipClient> _createBackgroundClient() async {
    final backgroundClient = TelnyxVoipClient(
      enableNativeUI: true,
      enableBackgroundHandling: true,
      customTokenProvider: telnyx.DefaultPushTokenProvider(),
      isBackgroundClient:
          true, // Mark as background client for proper disposal handling
    );
    return backgroundClient;
  }
}

class _TelnyxVoiceAppState extends State<TelnyxVoiceApp>
    with WidgetsBindingObserver {
  bool _processingPushOnLaunch = false;

  // Track current connection state
  telnyx_state.ConnectionState _currentConnectionState =
      const telnyx_state.Disconnected();
  StreamSubscription<telnyx_state.ConnectionState>?
      _connectionStateSubscription;

  @override
  void initState() {
    super.initState();

    // Add lifecycle observer for background detection
    if (!widget.skipWebBackgroundDetection || !kIsWeb) {
      WidgetsBinding.instance.addObserver(this);
    }

    // Listen to connection state changes
    _connectionStateSubscription =
        widget.voipClient.connectionState.listen((state) {
      _currentConnectionState = state;
    });

    // Handle initial push notification if app was launched from terminated state
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _checkForInitialPushNotification();
    });
  }

  @override
  void dispose() {
    _connectionStateSubscription?.cancel();
    if (!widget.skipWebBackgroundDetection || !kIsWeb) {
      WidgetsBinding.instance.removeObserver(this);
    }
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);

    // Store the last state for reference

    // Call optional user callback first
    widget.onAppLifecycleStateChanged?.call(state);

    // Handle auto-reconnection logic
    if (widget.enableAutoReconnect) {
      _handleAppLifecycleStateChange(state);
    }
  }

  /// Handle app lifecycle changes for auto-reconnection
  void _handleAppLifecycleStateChange(AppLifecycleState state) {
    switch (state) {
      case AppLifecycleState.resumed:
        _handleAppResumed();
        break;
      case AppLifecycleState.paused:
      case AppLifecycleState.detached:
      case AppLifecycleState.inactive:
        // App going to background - disconnect (matches old BackgroundDetector behavior)
        _handleAppBackgrounded();
        break;
      case AppLifecycleState.hidden:
        // New state in Flutter 3.13+
        break;
    }
  }

  /// Handle app going to background - disconnect like the old implementation
  void _handleAppBackgrounded() async {
    // Check if we should ignore background detection (e.g., during active calls)
    if (BackgroundDetector.ignore) {
      if (kDebugMode) {
        debugPrint(
            '[TelnyxVoiceApp] Background detector ignore flag set - skipping disconnection');
      }
      return;
    }

    if (kDebugMode) {
      debugPrint(
          '[TelnyxVoiceApp] App backgrounded - disconnecting (matching old BackgroundDetector behavior)');
    }

    try {
      // Always disconnect when backgrounded (matches old implementation)
      await widget.voipClient.logout();

      if (kDebugMode) {
        debugPrint('[TelnyxVoiceApp] Successfully disconnected on background');
      }
    } catch (e) {
      if (kDebugMode) {
        debugPrint('[TelnyxVoiceApp] Error disconnecting on background: $e');
      }
    }
  }

  /// Handle app resuming from background
  void _handleAppResumed() async {
    if (kDebugMode) {
      debugPrint('[TelnyxVoiceApp] App resumed - checking reconnection needs');
    }

    // IMPORTANT: Check for push notifications first when resuming from background
    // This handles the case where the user accepted a call while the app was backgrounded
    await _checkForInitialPushNotification();

    // If we're ignoring (e.g., from push call), don't auto-reconnect
    if (BackgroundDetector.ignore) {
      if (kDebugMode) {
        debugPrint(
            '[TelnyxVoiceApp] Background detector ignore flag set - skipping reconnection');
      }
      return;
    }

    // Check current connection state and reconnect if needed
    final currentConnectionState = _currentConnectionState;

    if (kDebugMode) {
      debugPrint(
          '[TelnyxVoiceApp] Current connection state: $currentConnectionState');
    }

    // If we're not connected and have stored credentials, attempt reconnection
    if (currentConnectionState is! telnyx_state.Connected) {
      await _attemptAutoReconnection();
    }
  }

  /// Attempt to reconnect using stored credentials
  Future<void> _attemptAutoReconnection() async {
    try {
      if (kDebugMode) {
        debugPrint('[TelnyxVoiceApp] Attempting auto-reconnection...');
      }

      // Try to get stored config and reconnect
      // This uses the same logic as the old implementation
      final success = await widget.voipClient.loginFromStoredConfig();

      if (kDebugMode) {
        debugPrint(
            '[TelnyxVoiceApp] Auto-reconnection ${success ? 'successful' : 'failed'}');
      }
    } catch (e) {
      if (kDebugMode) {
        debugPrint('[TelnyxVoiceApp] Auto-reconnection error: $e');
      }
    }
  }

  /// Check for initial push notification when app launches
  Future<void> _checkForInitialPushNotification() async {
    if (_processingPushOnLaunch) return;

    _processingPushOnLaunch = true;
    widget.onPushNotificationProcessingStarted?.call();

    try {
      Map<String, dynamic>? pushData;

      // Try Firebase first (Android)
      if (!kIsWeb && Platform.isAndroid) {
        final initialMessage =
            await FirebaseMessaging.instance.getInitialMessage();
        if (initialMessage != null) {
          if (kDebugMode) {
            debugPrint(
                '[TelnyxVoiceApp] Found initial Firebase message: ${initialMessage.data}');
          }
          pushData = _convertFirebaseMessageToPushData(initialMessage);
        }
      }

      // Fallback to TelnyxClient.getPushData() for iOS or if Firebase didn't have data
      if (pushData == null) {
        final storedPushData = await TelnyxClient.getPushData();
        if (storedPushData != null && storedPushData.isNotEmpty) {
          if (kDebugMode) {
            debugPrint('[TelnyxVoiceApp] Found stored push data: $storedPushData');
          }
          pushData = storedPushData;
        }
      }

      // Process the push notification if found
      if (pushData != null) {
        if (kDebugMode) {
          debugPrint('[TelnyxVoiceApp] Processing initial push notification...');
        }

        // Set the ignore flag to prevent auto-reconnection during push call
        BackgroundDetector.ignore = true;
        if (kDebugMode) {
          debugPrint('[TelnyxVoiceApp] Background detector ignore set to: true');
        }

        // The gateway expects the original payload structure with a "metadata" key.
        final Map<String, dynamic> formattedPushData = {
          'metadata': pushData,
        };

        // Handle the push notification
        await widget.voipClient.handlePushNotification(formattedPushData);

        if (kDebugMode) {
          debugPrint('[TelnyxVoiceApp] Initial push notification processed');
        }
      } else {
        if (kDebugMode) {
          debugPrint('[TelnyxVoiceApp] No initial push data found');
        }
      }
    } catch (e) {
      if (kDebugMode) {
        debugPrint(
            '[TelnyxVoiceApp] Error processing initial push notification: $e');
      }
    } finally {
      _processingPushOnLaunch = false;
      widget.onPushNotificationProcessingCompleted?.call();
    }
  }

  /// Convert Firebase RemoteMessage to push data format
  Map<String, dynamic> _convertFirebaseMessageToPushData(
      RemoteMessage message) {
    final data = Map<String, dynamic>.from(message.data);

    // Ensure metadata is properly formatted
    if (data['metadata'] is String) {
      try {
        data['metadata'] = jsonDecode(data['metadata']);
      } catch (e) {
        if (kDebugMode) {
          debugPrint('[TelnyxVoiceApp] Failed to parse metadata JSON: $e');
        }
      }
    }

    return data;
  }

  @override
  Widget build(BuildContext context) {
    // Simply return the child - all lifecycle management is handled internally
    return widget.child;
  }
}
